{"ast":null,"code":"import { isInteger } from '../../../utils/number.js';\nimport { factory } from '../../../utils/factory.js';\nimport { createCsSqr } from '../sparse/csSqr.js';\nimport { createCsLu } from '../sparse/csLu.js';\nvar name = 'slu';\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'transpose', 'divideScalar', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nexport var createSlu = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      abs = _ref.abs,\n      add = _ref.add,\n      multiply = _ref.multiply,\n      transpose = _ref.transpose,\n      divideScalar = _ref.divideScalar,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      largerEq = _ref.largerEq,\n      SparseMatrix = _ref.SparseMatrix;\n  var csSqr = createCsSqr({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csLu = createCsLu({\n    abs: abs,\n    divideScalar: divideScalar,\n    multiply: multiply,\n    subtract: subtract,\n    larger: larger,\n    largerEq: largerEq,\n    SparseMatrix: SparseMatrix\n  });\n  /**\n   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where\n   *\n   * `P * A * Q = L * U`\n   *\n   * Syntax:\n   *\n   *    math.slu(A, order, threshold)\n   *\n   * Examples:\n   *\n   *    const A = math.sparse([[4,3], [6, 3]])\n   *    math.slu(A, 1, 0.001)\n   *    // returns:\n   *    // {\n   *    //   L: [[1, 0], [1.5, 1]]\n   *    //   U: [[4, 3], [0, -1.5]]\n   *    //   p: [0, 1]\n   *    //   q: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lsolve, usolve, lusolve\n   *\n   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.\n   * @param {Number}       order          The Symbolic Ordering and Analysis order:\n   *                                       0 - Natural ordering, no permutation vector q is returned\n   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'\n   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.\n   *                                           This is appropriatefor LU factorization of unsymmetric matrices.\n   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.\n   *                                           A dense row is a row with more than 10*sqr(columns) entries.\n   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.\n   */\n\n  return typed(name, {\n    'SparseMatrix, number, number': function SparseMatrixNumberNumber(a, order, threshold) {\n      // verify order\n      if (!isInteger(order) || order < 0 || order > 3) {\n        throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');\n      } // verify threshold\n\n\n      if (threshold < 0 || threshold > 1) {\n        throw new Error('Partial pivoting threshold must be a number from 0 to 1');\n      } // perform symbolic ordering and analysis\n\n\n      var s = csSqr(order, a, false); // perform lu decomposition\n\n      var f = csLu(a, s, threshold); // return decomposition\n\n      return {\n        L: f.L,\n        U: f.U,\n        p: f.pinv,\n        q: s.q,\n        toString: function toString() {\n          return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\np: ' + this.p.toString() + (this.q ? '\\nq: ' + this.q.toString() : '') + '\\n';\n        }\n      };\n    }\n  });\n});","map":{"version":3,"sources":["/Users/macpro/GITHUB/REPOS/Calculator/node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js"],"names":["isInteger","factory","createCsSqr","createCsLu","name","dependencies","createSlu","_ref","typed","abs","add","multiply","transpose","divideScalar","subtract","larger","largerEq","SparseMatrix","csSqr","csLu","SparseMatrixNumberNumber","a","order","threshold","Error","s","f","L","U","p","pinv","q","toString"],"mappings":"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","sourcesContent":["import { isInteger } from '../../../utils/number.js';\nimport { factory } from '../../../utils/factory.js';\nimport { createCsSqr } from '../sparse/csSqr.js';\nimport { createCsLu } from '../sparse/csLu.js';\nvar name = 'slu';\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'transpose', 'divideScalar', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nexport var createSlu = /* #__PURE__ */factory(name, dependencies, (_ref) => {\n  var {\n    typed,\n    abs,\n    add,\n    multiply,\n    transpose,\n    divideScalar,\n    subtract,\n    larger,\n    largerEq,\n    SparseMatrix\n  } = _ref;\n  var csSqr = createCsSqr({\n    add,\n    multiply,\n    transpose\n  });\n  var csLu = createCsLu({\n    abs,\n    divideScalar,\n    multiply,\n    subtract,\n    larger,\n    largerEq,\n    SparseMatrix\n  });\n  /**\n   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where\n   *\n   * `P * A * Q = L * U`\n   *\n   * Syntax:\n   *\n   *    math.slu(A, order, threshold)\n   *\n   * Examples:\n   *\n   *    const A = math.sparse([[4,3], [6, 3]])\n   *    math.slu(A, 1, 0.001)\n   *    // returns:\n   *    // {\n   *    //   L: [[1, 0], [1.5, 1]]\n   *    //   U: [[4, 3], [0, -1.5]]\n   *    //   p: [0, 1]\n   *    //   q: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lsolve, usolve, lusolve\n   *\n   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.\n   * @param {Number}       order          The Symbolic Ordering and Analysis order:\n   *                                       0 - Natural ordering, no permutation vector q is returned\n   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'\n   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.\n   *                                           This is appropriatefor LU factorization of unsymmetric matrices.\n   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.\n   *                                           A dense row is a row with more than 10*sqr(columns) entries.\n   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.\n   */\n\n  return typed(name, {\n    'SparseMatrix, number, number': function SparseMatrixNumberNumber(a, order, threshold) {\n      // verify order\n      if (!isInteger(order) || order < 0 || order > 3) {\n        throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');\n      } // verify threshold\n\n\n      if (threshold < 0 || threshold > 1) {\n        throw new Error('Partial pivoting threshold must be a number from 0 to 1');\n      } // perform symbolic ordering and analysis\n\n\n      var s = csSqr(order, a, false); // perform lu decomposition\n\n      var f = csLu(a, s, threshold); // return decomposition\n\n      return {\n        L: f.L,\n        U: f.U,\n        p: f.pinv,\n        q: s.q,\n        toString: function toString() {\n          return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\np: ' + this.p.toString() + (this.q ? '\\nq: ' + this.q.toString() : '') + '\\n';\n        }\n      };\n    }\n  });\n});"]},"metadata":{},"sourceType":"module"}