{"ast":null,"code":"/*! css-doodle@0.15.3 */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.CSSDoodle = factory());\n})(this, function () {\n  'use strict';\n\n  function iterator(input) {\n    let index = 0,\n        col = 1,\n        line = 1;\n    return {\n      curr(n = 0) {\n        return input[index + n];\n      },\n\n      end() {\n        return input.length <= index;\n      },\n\n      info() {\n        return {\n          index,\n          col,\n          line\n        };\n      },\n\n      index(n) {\n        return n === undefined ? index : index = n;\n      },\n\n      next() {\n        let next = input[index++];\n        if (next == '\\n') line++, col = 0;else col++;\n        return next;\n      }\n\n    };\n  } // I'll make it work first\n\n\n  function parse(it) {\n    let word = '',\n        marks = [];\n    let groups = [],\n        result = {};\n\n    while (!it.end()) {\n      let c = it.curr();\n\n      if (c == '(') {\n        marks.push(c);\n        word = '';\n      } else if (c == ')' || c == ',') {\n        if (/^\\-\\-.+/.test(word)) {\n          if (!result.name) {\n            result.name = word;\n          } else {\n            if (!result.alternative) {\n              result.alternative = [];\n            }\n\n            result.alternative.push({\n              name: word\n            });\n          }\n        }\n\n        if (c == ')') {\n          if (marks[marks.length - 1] == '(') {\n            marks.pop();\n          } else {\n            throw new Error('bad match');\n          }\n        }\n\n        if (c == ',') {\n          if (!marks.length) {\n            groups.push(result);\n            result = {};\n          }\n        }\n\n        word = '';\n      } else if (!/\\s/.test(c)) {\n        word += c;\n      }\n\n      it.next();\n    }\n\n    if (marks.length) {\n      return [];\n    }\n\n    if (result.name) {\n      groups.push(result);\n    }\n\n    return groups;\n  }\n\n  function parse_var(input) {\n    input = input.trim();\n    let result = [];\n\n    if (!/^var\\(/.test(input)) {\n      return result;\n    }\n\n    let it = iterator(input);\n\n    try {\n      result = parse(it);\n    } catch (e) {\n      console.warn(e && e.message || 'Bad variables.');\n    }\n\n    return result;\n  }\n\n  function List(random) {\n    function make_array(arr) {\n      return Array.isArray(arr) ? arr : [arr];\n    }\n\n    function join(arr, spliter = '\\n') {\n      return (arr || []).join(spliter);\n    }\n\n    function last(arr, n = 1) {\n      return arr[arr.length - n];\n    }\n\n    function first(arr) {\n      return arr[0];\n    }\n\n    function clone(arr) {\n      return JSON.parse(JSON.stringify(arr));\n    }\n\n    function shuffle(arr) {\n      let ret = Array.from ? Array.from(arr) : arr.slice();\n      let m = arr.length;\n\n      while (m) {\n        let i = ~~(random() * m--);\n        let t = ret[m];\n        ret[m] = ret[i];\n        ret[i] = t;\n      }\n\n      return ret;\n    }\n\n    function flat_map(arr, fn) {\n      if (Array.prototype.flatMap) return arr.flatMap(fn);\n      return arr.reduce((acc, x) => acc.concat(fn(x)), []);\n    }\n\n    function remove_empty_values(arr) {\n      return arr.filter(v => v !== undefined && v !== null && String(v).trim().length);\n    }\n\n    return {\n      make_array,\n      join,\n      last,\n      first,\n      clone,\n      shuffle,\n      flat_map,\n      remove_empty_values\n    };\n  }\n\n  let {\n    first,\n    last,\n    clone\n  } = List();\n  const Tokens = {\n    func(name = '') {\n      return {\n        type: 'func',\n        name,\n        arguments: []\n      };\n    },\n\n    argument() {\n      return {\n        type: 'argument',\n        value: []\n      };\n    },\n\n    text(value = '') {\n      return {\n        type: 'text',\n        value\n      };\n    },\n\n    pseudo(selector = '') {\n      return {\n        type: 'pseudo',\n        selector,\n        styles: []\n      };\n    },\n\n    cond(name = '') {\n      return {\n        type: 'cond',\n        name,\n        styles: [],\n        arguments: []\n      };\n    },\n\n    rule(property = '') {\n      return {\n        type: 'rule',\n        property,\n        value: []\n      };\n    },\n\n    keyframes(name = '') {\n      return {\n        type: 'keyframes',\n        name,\n        steps: []\n      };\n    },\n\n    step(name = '') {\n      return {\n        type: 'step',\n        name,\n        styles: []\n      };\n    }\n\n  };\n  const is = {\n    white_space(c) {\n      return /[\\s\\n\\t]/.test(c);\n    },\n\n    line_break(c) {\n      return /\\n/.test(c);\n    },\n\n    number(n) {\n      return !isNaN(n);\n    },\n\n    pair(n) {\n      return ['\"', '(', ')', \"'\"].includes(n);\n    },\n\n    pair_of(c, n) {\n      return {\n        '\"': '\"',\n        \"'\": \"'\",\n        '(': ')'\n      }[c] == n;\n    }\n\n  }; // This should not be in the parser\n  // but I'll leave it here until the rewriting\n\n  const symbols = {\n    'π': Math.PI,\n    '∏': Math.PI\n  };\n\n  function throw_error(msg, {\n    col,\n    line\n  }) {\n    console.warn(`(at line ${line}, column ${col}) ${msg}`);\n  }\n\n  function get_text_value(input) {\n    if (input.trim().length) {\n      return is.number(+input) ? +input : input.trim();\n    } else {\n      return input;\n    }\n  }\n\n  function read_until(fn) {\n    return function (it, reset) {\n      let index = it.index();\n      let word = '';\n\n      while (!it.end()) {\n        let c = it.next();\n        if (fn(c)) break;else word += c;\n      }\n\n      if (reset) {\n        it.index(index);\n      }\n\n      return word;\n    };\n  }\n\n  function read_word(it, reset) {\n    let check = c => /[^\\w@]/.test(c);\n\n    return read_until(check)(it, reset);\n  }\n\n  function read_keyframe_name(it) {\n    return read_until(c => /[\\s\\{]/.test(c))(it);\n  }\n\n  function read_line(it, reset) {\n    let check = c => is.line_break(c) || c == '{';\n\n    return read_until(check)(it, reset);\n  }\n\n  function read_step(it, extra) {\n    let c,\n        step = Tokens.step();\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      } else if (!step.name.length) {\n        step.name = read_selector(it);\n      } else {\n        step.styles.push(read_rule(it, extra));\n        if (it.curr() == '}') break;\n      }\n\n      it.next();\n    }\n\n    return step;\n  }\n\n  function read_steps(it, extra) {\n    const steps = [];\n    let c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;else if (is.white_space(c)) {\n        it.next();\n        continue;\n      } else {\n        steps.push(read_step(it, extra));\n      }\n      it.next();\n    }\n\n    return steps;\n  }\n\n  function read_keyframes(it, extra) {\n    let keyframes = Tokens.keyframes(),\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;else if (!keyframes.name.length) {\n        read_word(it);\n        keyframes.name = read_keyframe_name(it);\n\n        if (!keyframes.name.length) {\n          throw_error('missing keyframes name', it.info());\n          break;\n        }\n\n        continue;\n      } else if (c == '{') {\n        it.next();\n        keyframes.steps = read_steps(it, extra);\n        break;\n      }\n      it.next();\n    }\n\n    return keyframes;\n  }\n\n  function read_comments(it, flag = {}) {\n    it.next();\n\n    while (!it.end()) {\n      let c = it.curr();\n\n      if (flag.inline) {\n        if (c == '\\n') break;\n      } else {\n        if ((c = it.curr()) == '*' && it.curr(1) == '/') break;\n      }\n\n      it.next();\n    }\n\n    if (!flag.inline) {\n      it.next();\n      it.next();\n    }\n  }\n\n  function read_tag(it) {\n    it.next();\n\n    while (!it.end()) {\n      let c = it.curr();\n      if (c == '>') break;\n      it.next();\n    }\n  }\n\n  function read_property(it) {\n    let prop = '',\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == ':') break;else if (!is.white_space(c)) prop += c;\n      it.next();\n    }\n\n    return prop;\n  }\n\n  function read_arguments(it, composition, doodle) {\n    let args = [],\n        group = [],\n        stack = [],\n        arg = '',\n        c;\n\n    while (!it.end()) {\n      c = it.curr();\n\n      if (/[\\('\"`]/.test(c) && it.curr(-1) !== '\\\\') {\n        if (stack.length) {\n          if (c != '(' && c === last(stack)) {\n            stack.pop();\n          } else {\n            stack.push(c);\n          }\n        } else {\n          stack.push(c);\n        }\n\n        arg += c;\n      } else if (c == '@' && !doodle) {\n        if (!group.length) {\n          arg = arg.trimLeft();\n        }\n\n        if (arg.length) {\n          group.push(Tokens.text(arg));\n          arg = '';\n        }\n\n        group.push(read_func(it));\n      } else if (doodle && /[)]/.test(c) || !doodle && /[,)]/.test(c)) {\n        if (stack.length) {\n          if (c == ')') {\n            stack.pop();\n          }\n\n          arg += c;\n        } else {\n          if (arg.length) {\n            if (!group.length) {\n              group.push(Tokens.text(get_text_value(arg)));\n            } else {\n              group.push(Tokens.text(arg));\n            }\n\n            if (arg.startsWith('±') && !doodle) {\n              let raw = arg.substr(1);\n              let cloned = clone(group);\n              last(cloned).value = '-' + raw;\n              args.push(normalize_argument(cloned));\n              last(group).value = raw;\n            }\n          }\n\n          args.push(normalize_argument(group));\n          [group, arg] = [[], ''];\n          if (c == ')') break;\n        }\n      } else {\n        if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n          c = symbols[c];\n        }\n\n        arg += c;\n      }\n\n      if (composition && it.curr() == ')' && !stack.length) {\n        if (group.length) {\n          args.push(normalize_argument(group));\n        }\n\n        break;\n      } else {\n        it.next();\n      }\n    }\n\n    return args;\n  }\n\n  function normalize_argument(group) {\n    let result = group.map(arg => {\n      if (arg.type == 'text' && typeof arg.value == 'string') {\n        let value = String(arg.value);\n\n        if (value.includes('`')) {\n          arg.value = value = value.replace(/`/g, '\"');\n        }\n\n        arg.value = value.replace(/\\n+|\\s+/g, ' ');\n      }\n\n      return arg;\n    });\n    let ft = first(result) || {};\n    let ed = last(result) || {};\n\n    if (ft.type == 'text' && ed.type == 'text') {\n      let cf = first(ft.value);\n      let ce = last(ed.value);\n\n      if (typeof ft.value == 'string' && typeof ed.value == 'string') {\n        if (is.pair_of(cf, ce)) {\n          ft.value = ft.value.slice(1);\n          ed.value = ed.value.slice(0, ed.value.length - 1);\n          result.cluster = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function seperate_func_name(name) {\n    let fname = '',\n        extra = '';\n\n    if (/\\D$/.test(name) && !/\\d+x\\d+/.test(name) || Math[name.substr(1)]) {\n      return {\n        fname: name,\n        extra\n      };\n    }\n\n    for (let i = name.length - 1; i >= 0; i--) {\n      let c = name[i];\n      let prev = name[i - 1];\n      let next = name[i + 1];\n\n      if (/[\\d.]/.test(c) || c == 'x' && /\\d/.test(prev) && /\\d/.test(next)) {\n        extra = c + extra;\n      } else {\n        fname = name.substring(0, i + 1);\n        break;\n      }\n    }\n\n    return {\n      fname,\n      extra\n    };\n  }\n\n  function read_func(it) {\n    let func = Tokens.func();\n    let name = '@',\n        c;\n    let has_argument = false;\n    it.next();\n\n    while (!it.end()) {\n      c = it.curr();\n      let composition = c == '.' && it.curr(1) == '@';\n      let next = it.curr(1);\n\n      if (c == '(' || composition) {\n        has_argument = true;\n        it.next();\n        func.arguments = read_arguments(it, composition, name === '@doodle' || name == '@shaders');\n        break;\n      } else if (!has_argument && next !== '(' && !/[0-9a-zA-Z_\\-.]/.test(next)) {\n        name += c;\n        break;\n      } else {\n        name += c;\n      }\n\n      it.next();\n    }\n\n    let {\n      fname,\n      extra\n    } = seperate_func_name(name);\n    func.name = fname;\n\n    if (extra.length) {\n      func.arguments.unshift([{\n        type: 'text',\n        value: extra\n      }]);\n    }\n\n    func.position = it.info().index;\n    return func;\n  }\n\n  function read_value(it) {\n    let text = Tokens.text(),\n        idx = 0,\n        skip = true,\n        c;\n    const value = [],\n          stack = [];\n    value[idx] = [];\n\n    while (!it.end()) {\n      c = it.curr();\n\n      if (skip && is.white_space(c)) {\n        it.next();\n        continue;\n      } else {\n        skip = false;\n      }\n\n      if (c == '\\n' && !is.white_space(it.curr(-1))) {\n        text.value += ' ';\n      } else if (c == ',' && !stack.length) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n\n        value[++idx] = [];\n        skip = true;\n      } else if (/[;}]/.test(c)) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n\n        break;\n      } else if (c == '@') {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n\n        value[idx].push(read_func(it));\n      } else if (!is.white_space(c) || !is.white_space(it.curr(-1))) {\n        if (c == '(') stack.push(c);\n        if (c == ')') stack.pop();\n\n        if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n          c = symbols[c];\n        }\n\n        text.value += c;\n      }\n\n      it.next();\n    }\n\n    if (text.value.length) {\n      value[idx].push(text);\n    }\n\n    return value;\n  }\n\n  function read_selector(it) {\n    let selector = '',\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '{') break;else if (!is.white_space(c)) {\n        selector += c;\n      }\n      it.next();\n    }\n\n    return selector;\n  }\n\n  function read_cond_selector(it) {\n    let selector = {\n      name: '',\n      arguments: []\n    },\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '(') {\n        it.next();\n        selector.arguments = read_arguments(it);\n      } else if (/[){]/.test(c)) break;else if (!is.white_space(c)) selector.name += c;\n\n      it.next();\n    }\n\n    return selector;\n  }\n\n  function read_pseudo(it, extra) {\n    let pseudo = Tokens.pseudo(),\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      } else if (!pseudo.selector) {\n        pseudo.selector = read_selector(it);\n      } else {\n        let rule = read_rule(it, extra);\n\n        if (rule.property == '@use') {\n          pseudo.styles = pseudo.styles.concat(rule.value);\n        } else {\n          pseudo.styles.push(rule);\n        }\n\n        if (it.curr() == '}') break;\n      }\n\n      it.next();\n    }\n\n    return pseudo;\n  }\n\n  function read_rule(it, extra) {\n    let rule = Tokens.rule(),\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == ';') break;else if (!rule.property.length) {\n        rule.property = read_property(it);\n\n        if (rule.property == '@use') {\n          rule.value = read_var(it, extra);\n          break;\n        }\n      } else {\n        rule.value = read_value(it);\n        break;\n      }\n      it.next();\n    }\n\n    return rule;\n  }\n\n  function read_cond(it, extra) {\n    let cond = Tokens.cond(),\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;else if (!cond.name.length) {\n        Object.assign(cond, read_cond_selector(it));\n      } else if (c == ':') {\n        let pseudo = read_pseudo(it);\n        if (pseudo.selector) cond.styles.push(pseudo);\n      } else if (c == '@' && !read_line(it, true).includes(':')) {\n        cond.styles.push(read_cond(it));\n      } else if (!is.white_space(c)) {\n        let rule = read_rule(it, extra);\n        if (rule.property) cond.styles.push(rule);\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n\n    return cond;\n  }\n\n  function read_variable(extra, name) {\n    let rule = '';\n\n    if (extra && extra.get_variable) {\n      rule = extra.get_variable(name);\n    }\n\n    return rule;\n  }\n\n  function evaluate_value(values, extra) {\n    values.forEach && values.forEach(v => {\n      if (v.type == 'text' && v.value) {\n        let vars = parse_var(v.value);\n        v.value = vars.reduce((ret, p) => {\n          let rule = '',\n              other = '',\n              parsed;\n          rule = read_variable(extra, p.name);\n\n          if (!rule && p.alternative) {\n            p.alternative.every(n => {\n              other = read_variable(extra, n.name);\n\n              if (other) {\n                rule = other;\n                return false;\n              }\n            });\n          }\n\n          try {\n            parsed = parse$1(rule, extra);\n          } catch (e) {}\n\n          if (parsed) {\n            ret.push.apply(ret, parsed);\n          }\n\n          return ret;\n        }, []);\n      }\n\n      if (v.type == 'func' && v.arguments) {\n        v.arguments.forEach(arg => {\n          evaluate_value(arg, extra);\n        });\n      }\n    });\n  }\n\n  function read_var(it, extra) {\n    it.next();\n    let groups = read_value(it) || [];\n    return groups.reduce((ret, group) => {\n      evaluate_value(group, extra);\n      let [token] = group;\n\n      if (token.value && token.value.length) {\n        ret.push(...token.value);\n      }\n\n      return ret;\n    }, []);\n  }\n\n  function parse$1(input, extra) {\n    const it = iterator(input);\n    const Tokens = [];\n\n    while (!it.end()) {\n      let c = it.curr();\n\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      } else if (c == '/' && it.curr(1) == '*') {\n        read_comments(it);\n      } else if (c == '/' && it.curr(1) == '/') {\n        read_comments(it, {\n          inline: true\n        });\n      } else if (c == ':') {\n        let pseudo = read_pseudo(it, extra);\n        if (pseudo.selector) Tokens.push(pseudo);\n      } else if (c == '@' && read_word(it, true) === '@keyframes') {\n        let keyframes = read_keyframes(it, extra);\n        Tokens.push(keyframes);\n      } else if (c == '@' && !read_line(it, true).includes(':')) {\n        let cond = read_cond(it, extra);\n        if (cond.name.length) Tokens.push(cond);\n      } else if (c == '<') {\n        read_tag(it);\n      } else if (!is.white_space(c)) {\n        let rule = read_rule(it, extra);\n        if (rule.property) Tokens.push(rule);\n      }\n\n      it.next();\n    }\n\n    return Tokens;\n  }\n\n  function clamp(num, min, max) {\n    return Math.max(min, Math.min(max, num));\n  }\n\n  function maybe(cond, value) {\n    if (!cond) return '';\n    return typeof value === 'function' ? value() : value;\n  }\n\n  function range(start, stop, step) {\n    let count = 0,\n        old = start;\n\n    let initial = n => n > 0 && n < 1 ? .1 : 1;\n\n    let length = arguments.length;\n    if (length == 1) [start, stop] = [initial(start), start];\n    if (length < 3) step = initial(start);\n    let range = [];\n\n    while (step >= 0 && start <= stop || step < 0 && start > stop) {\n      range.push(start);\n      start += step;\n      if (count++ >= 1000) break;\n    }\n\n    if (!range.length) range.push(old);\n    return range;\n  }\n\n  function alias_for(obj, names) {\n    Object.keys(names).forEach(n => {\n      obj[n] = obj[names[n]];\n    });\n    return obj;\n  }\n\n  function is_letter(c) {\n    return /^[a-zA-Z]$/.test(c);\n  }\n\n  function is_nil(s) {\n    return s === undefined || s === null;\n  }\n\n  function lazy(fn) {\n    let wrap = () => fn;\n\n    wrap.lazy = true;\n    return wrap;\n  }\n\n  function sequence(count, fn) {\n    let [x, y = 1] = String(count).split('x');\n    x = clamp(parseInt(x) || 1, 1, 65536);\n    y = clamp(parseInt(y) || 1, 1, 65536);\n    let max = x * y;\n    let ret = [];\n    let index = 1;\n\n    for (let i = 1; i <= y; ++i) {\n      for (let j = 1; j <= x; ++j) {\n        ret.push(fn(index++, j, i, max));\n      }\n    }\n\n    return ret;\n  }\n\n  function cell_id(x, y, z) {\n    return 'c-' + x + '-' + y + '-' + z;\n  }\n\n  function get_value(input) {\n    while (input && input.value) {\n      return get_value(input.value);\n    }\n\n    return is_nil(input) ? '' : input;\n  }\n\n  function normalize_png_name(name) {\n    let prefix = is_nil(name) ? Date.now() : String(name).replace(/\\/.png$/g, '');\n    return prefix + '.png';\n  }\n\n  function cache_image(src, fn, delay = 0) {\n    let img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.src = src;\n\n    img.onload = function () {\n      setTimeout(fn, delay);\n    };\n  }\n\n  function is_safari() {\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  }\n\n  function un_entity(code) {\n    let textarea = document.createElement('textarea');\n    textarea.innerHTML = code;\n    return textarea.value;\n  }\n\n  const [min, max, total] = [1, 32, 32 * 32];\n\n  function parse_grid(size) {\n    let [x, y, z] = (size + '').replace(/\\s+/g, '').replace(/[,，xX]+/g, 'x').split('x').map(n => parseInt(n));\n    const max_xy = x == 1 || y == 1 ? total : max;\n    const max_z = x == 1 && y == 1 ? total : min;\n    const ret = {\n      x: clamp(x || min, 1, max_xy),\n      y: clamp(y || x || min, 1, max_xy),\n      z: clamp(z || min, 1, max_z)\n    };\n    return Object.assign({}, ret, {\n      count: ret.x * ret.y * ret.z\n    });\n  }\n\n  function is_quote(c) {\n    return c == '\"' || c == \"'\";\n  }\n\n  function last$1(array) {\n    return array[array.length - 1];\n  }\n\n  function parse$2(input) {\n    let c = '';\n    let temp = '';\n    let name = '';\n    let stack = [];\n    let result = {\n      textures: []\n    };\n    let w = '';\n    let words = [];\n    let i = 0;\n\n    while ((c = input[i++]) !== undefined) {\n      if (c == '\"' || c == \"'\") {\n        if (last$1(stack) == c) {\n          stack.pop();\n        } else {\n          stack.push(c);\n        }\n      }\n\n      if (c == '{' && !is_quote(last$1(stack))) {\n        if (!stack.length) {\n          name = temp;\n          temp = '';\n        } else {\n          temp += c;\n        }\n\n        stack.push(c);\n      } else if (c == '}' && !is_quote(last$1(stack))) {\n        stack.pop();\n\n        if (!stack.length) {\n          let key = name.trim();\n          let value = temp.trim().replace(/^\\(+|\\)+$/g, '');\n\n          if (key.length) {\n            if (key.startsWith('texture')) {\n              result.textures.push({\n                name: key,\n                value: value\n              });\n            } else {\n              result[key] = value;\n            }\n          }\n\n          name = temp = '';\n        } else {\n          temp += c;\n        }\n      } else {\n        if (/\\s/.test(c) && w.length) {\n          words.push(w);\n          w = '';\n          let need_break = words[words.length - 3] == '#define' || words[words.length - 2] == '#ifdef' || words[words.length - 1] == '#else' || words[words.length - 1] == '#endif';\n\n          if (need_break) {\n            temp = temp + '\\n';\n          }\n        } else {\n          w += c;\n        }\n\n        temp += c;\n      }\n    }\n\n    if (result.fragment === undefined) {\n      return {\n        fragment: input,\n        textures: []\n      };\n    }\n\n    return result;\n  }\n\n  function create_svg_url(svg, id) {\n    let encoded = encodeURIComponent(svg) + (id ? `#${id}` : '');\n    return `url(\"data:image/svg+xml;utf8,${encoded}\")`;\n  }\n\n  function normalize_svg(input) {\n    const xmlns = 'xmlns=\"http://www.w3.org/2000/svg\"';\n\n    if (!input.includes('<svg')) {\n      input = `<svg ${xmlns}>${input}</svg>`;\n    }\n\n    if (!input.includes('xmlns')) {\n      input = input.replace(/<svg([\\s>])/, `<svg ${xmlns}$1`);\n    }\n\n    return input;\n  }\n\n  function svg_to_png(svg, width, height, scale) {\n    return new Promise((resolve, reject) => {\n      let source = `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;\n\n      function action() {\n        let img = new Image();\n        img.crossOrigin = 'anonymous';\n        img.src = source;\n\n        img.onload = () => {\n          let canvas = document.createElement('canvas');\n          let ctx = canvas.getContext('2d');\n          let dpr = window.devicePixelRatio || 1;\n          /* scale with devicePixelRatio only when the scale equals 1 */\n\n          if (scale != 1) {\n            dpr = 1;\n          }\n\n          canvas.width = width * dpr;\n          canvas.height = height * dpr;\n          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n          try {\n            canvas.toBlob(blob => {\n              resolve({\n                blob,\n                source,\n                url: URL.createObjectURL(blob)\n              });\n            });\n          } catch (e) {\n            reject(e);\n          }\n        };\n      }\n\n      if (is_safari) {\n        cache_image(source, action, 200);\n      } else {\n        action();\n      }\n    });\n  }\n\n  function random_func(random) {\n    function lerp(start, end, t) {\n      return start * (1 - t) + end * t;\n    }\n\n    function rand(start = 0, end = start) {\n      if (arguments.length == 1) {\n        if (start == 1) start = 0;else if (start < 1) start /= 10;else start = 1;\n      }\n\n      return lerp(start, end, random());\n    }\n\n    function nrand(mean = 0, scale = 1) {\n      let u1 = 0,\n          u2 = 0; //Convert [0,1) to (0,1)\n\n      while (u1 === 0) u1 = random();\n\n      while (u2 === 0) u2 = random();\n\n      const R = Math.sqrt(-2.0 * Math.log(u1));\n      const t = 2.0 * Math.PI * u2;\n      const u0 = R * Math.cos(t);\n      return mean + scale * u0;\n    }\n\n    function pick(...items) {\n      let args = items.reduce((acc, n) => acc.concat(n), []);\n      return args[~~(random() * args.length)];\n    }\n\n    function unique_id(prefix = '') {\n      return prefix + Math.random().toString(32).substr(2);\n    }\n\n    return {\n      lerp,\n      rand,\n      nrand,\n      pick,\n      unique_id\n    };\n  }\n\n  function by_unit(fn) {\n    return (...args) => {\n      let unit = get_unit(args);\n      return restore(fn, unit).apply(null, args);\n    };\n  }\n\n  function restore(fn, unit) {\n    return (...args) => {\n      args = args.map(str => Number(String(str).replace(/\\D+$/g, '')));\n      let result = fn.apply(null, args);\n\n      if (!unit.length) {\n        return result;\n      }\n\n      if (Array.isArray(result)) {\n        return result.map(n => n + unit);\n      }\n\n      return result + unit;\n    };\n  }\n\n  function get_unit(values) {\n    let unit = '';\n    values.some(str => {\n      let input = String(str).trim();\n      if (!input) return '';\n      let matched = input.match(/\\d(\\D+)$/);\n      return unit = matched ? matched[1] : '';\n    });\n    return unit;\n  }\n\n  function by_charcode(fn) {\n    return (...args) => {\n      let codes = args.map(n => String(n).charCodeAt(0));\n      let result = fn.apply(null, codes);\n      return Array.isArray(result) ? result.map(n => String.fromCharCode(n)) : String.fromCharCode(result);\n    };\n  }\n  /**\n   * Based on the Shunting-yard algorithm.\n   */\n\n\n  let {\n    last: last$2\n  } = List();\n  const default_context = {\n    'π': Math.PI,\n    '∏': Math.PI\n  };\n\n  function calc(input, context) {\n    const expr = infix_to_postfix(input);\n    return calc$1(expr, Object.assign(default_context, context));\n  }\n\n  const operator = {\n    '^': 4,\n    '*': 3,\n    '/': 3,\n    '%': 3,\n    '+': 2,\n    '-': 2,\n    '(': 1,\n    ')': 1\n  };\n\n  function calc$1(expr, context, repeat = []) {\n    let stack = [];\n\n    while (expr.length) {\n      let {\n        name,\n        value,\n        type\n      } = expr.shift();\n\n      if (type === 'variable') {\n        let result = context[value];\n\n        if (typeof result === 'undefined') {\n          result = Math[value];\n        }\n\n        if (typeof result === 'undefined') {\n          result = expand(value, context);\n        }\n\n        if (typeof result === 'undefined') {\n          result = 0;\n        }\n\n        if (typeof result !== 'number') {\n          repeat.push(result);\n\n          if (is_cycle(repeat)) {\n            result = 0;\n            repeat = [];\n          } else {\n            result = calc$1(infix_to_postfix(result), context, repeat);\n          }\n        }\n\n        stack.push(result);\n      } else if (type === 'function') {\n        let output = value.map(v => calc$1(v, context));\n        let fns = name.split('.');\n        let fname;\n\n        while (fname = fns.pop()) {\n          if (!fname) continue;\n          let fn = context[fname] || Math[fname];\n          output = typeof fn === 'function' ? Array.isArray(output) ? fn(...output) : fn(output) : 0;\n        }\n\n        stack.push(output);\n      } else {\n        if (/\\d+/.test(value)) stack.push(value);else {\n          let right = stack.pop();\n          let left = stack.pop();\n          stack.push(compute(value, Number(left), Number(right)));\n        }\n      }\n    }\n\n    return stack[0];\n  }\n\n  function get_tokens(input) {\n    let expr = String(input);\n    let tokens = [],\n        num = '';\n\n    for (let i = 0; i < expr.length; ++i) {\n      let c = expr[i];\n\n      if (operator[c]) {\n        if (c == '-' && expr[i - 1] == 'e') {\n          num += c;\n        } else if (!tokens.length && !num.length && /[+-]/.test(c)) {\n          num += c;\n        } else {\n          let {\n            type,\n            value\n          } = last$2(tokens) || {};\n\n          if (type == 'operator' && !num.length && /[^()]/.test(c) && /[^()]/.test(value)) {\n            num += c;\n          } else {\n            if (num.length) {\n              tokens.push({\n                type: 'number',\n                value: num\n              });\n              num = '';\n            }\n\n            tokens.push({\n              type: 'operator',\n              value: c\n            });\n          }\n        }\n      } else if (/\\S/.test(c)) {\n        if (c == ',') {\n          tokens.push({\n            type: 'number',\n            value: num\n          });\n          num = '';\n          tokens.push({\n            type: 'comma',\n            value: c\n          });\n        } else {\n          num += c;\n        }\n      }\n    }\n\n    if (num.length) {\n      tokens.push({\n        type: 'number',\n        value: num\n      });\n    }\n\n    return tokens;\n  }\n\n  function infix_to_postfix(input) {\n    let tokens = get_tokens(input);\n    const op_stack = [],\n          expr = [];\n\n    for (let i = 0; i < tokens.length; ++i) {\n      let {\n        type,\n        value\n      } = tokens[i];\n      let next = tokens[i + 1] || {};\n\n      if (type == 'number') {\n        if (next.value == '(' && /[^\\d.]/.test(value)) {\n          let func_body = '';\n          let stack = [];\n          let values = [];\n          i += 1;\n\n          while (tokens[i++] !== undefined) {\n            let token = tokens[i];\n            if (token === undefined) break;\n            let c = token.value;\n\n            if (c == ')') {\n              if (!stack.length) break;\n              stack.pop();\n              func_body += c;\n            } else {\n              if (c == '(') stack.push(c);\n\n              if (c == ',' && !stack.length) {\n                let arg = infix_to_postfix(func_body);\n                if (arg.length) values.push(arg);\n                func_body = '';\n              } else {\n                func_body += c;\n              }\n            }\n          }\n\n          if (func_body.length) {\n            values.push(infix_to_postfix(func_body));\n          }\n\n          expr.push({\n            type: 'function',\n            name: value,\n            value: values\n          });\n        } else if (/[^\\d.]/.test(value)) {\n          expr.push({\n            type: 'variable',\n            value\n          });\n        } else {\n          expr.push({\n            type: 'number',\n            value\n          });\n        }\n      } else if (type == 'operator') {\n        if (value == '(') {\n          op_stack.push(value);\n        } else if (value == ')') {\n          while (op_stack.length && last$2(op_stack) != '(') {\n            expr.push({\n              type: 'operator',\n              value: op_stack.pop()\n            });\n          }\n\n          op_stack.pop();\n        } else {\n          while (op_stack.length && operator[last$2(op_stack)] >= operator[value]) {\n            let op = op_stack.pop();\n            if (!/[()]/.test(op)) expr.push({\n              type: 'operator',\n              value: op\n            });\n          }\n\n          op_stack.push(value);\n        }\n      }\n    }\n\n    while (op_stack.length) {\n      expr.push({\n        type: 'operator',\n        value: op_stack.pop()\n      });\n    }\n\n    return expr;\n  }\n\n  function compute(op, a, b) {\n    switch (op) {\n      case '+':\n        return a + b;\n\n      case '-':\n        return a - b;\n\n      case '*':\n        return a * b;\n\n      case '/':\n        return a / b;\n\n      case '%':\n        return a % b;\n\n      case '^':\n        return Math.pow(a, b);\n    }\n  }\n\n  function expand(value, context) {\n    let [_, num, variable] = value.match(/([\\d.]+)(.*)/) || [];\n    let v = context[variable];\n\n    if (v === undefined) {\n      return v;\n    }\n\n    if (typeof v === 'number') {\n      return Number(num) * v;\n    } else {\n      return num * calc$1(infix_to_postfix(v), context);\n    }\n  }\n\n  function is_cycle(array) {\n    return array[0] == array[2] && array[1] == array[3];\n  }\n\n  const store = {};\n\n  function memo(prefix, fn) {\n    return (...args) => {\n      let key = prefix + args.join('-');\n      if (store[key]) return store[key];\n      return store[key] = fn.apply(null, args);\n    };\n  }\n\n  const {\n    last: last$3,\n    flat_map\n  } = List();\n\n  function expand$1(fn) {\n    return (...args) => fn.apply(null, flat_map(args, n => String(n).startsWith('[') ? build_range(n) : n));\n  }\n\n  function Type(type, value) {\n    return {\n      type,\n      value\n    };\n  }\n\n  function get_tokens$1(input) {\n    let expr = String(input);\n    let tokens = [],\n        stack = [];\n\n    if (!expr.startsWith('[') || !expr.endsWith(']')) {\n      return tokens;\n    }\n\n    for (let i = 1; i < expr.length - 1; ++i) {\n      let c = expr[i];\n\n      if (c == '-' && expr[i - 1] == '-') {\n        continue;\n      }\n\n      if (c == '-') {\n        stack.push(c);\n        continue;\n      }\n\n      if (last$3(stack) == '-') {\n        stack.pop();\n        let from = stack.pop();\n        tokens.push(from ? Type('range', [from, c]) : Type('char', c));\n        continue;\n      }\n\n      if (stack.length) {\n        tokens.push(Type('char', stack.pop()));\n      }\n\n      stack.push(c);\n    }\n\n    if (stack.length) {\n      tokens.push(Type('char', stack.pop()));\n    }\n\n    return tokens;\n  }\n\n  const build_range = memo('build_range', input => {\n    let tokens = get_tokens$1(input);\n    return flat_map(tokens, ({\n      type,\n      value\n    }) => {\n      if (type == 'char') return value;\n      let [from, to] = value;\n      let reverse = false;\n\n      if (from > to) {\n        [from, to] = [to, from];\n        reverse = true;\n      }\n\n      let result = by_charcode(range)(from, to);\n      if (reverse) result.reverse();\n      return result;\n    });\n  });\n\n  class Node {\n    constructor(data) {\n      this.prev = this.next = null;\n      this.data = data;\n    }\n\n  }\n\n  class Stack {\n    constructor(limit = 20) {\n      this._limit = limit;\n      this._size = 0;\n    }\n\n    push(data) {\n      if (this._size >= this._limit) {\n        this.root = this.root.next;\n        this.root.prev = null;\n      }\n\n      let node = new Node(data);\n\n      if (!this.root) {\n        this.root = this.tail = node;\n      } else {\n        node.prev = this.tail;\n        this.tail.next = node;\n        this.tail = node;\n      }\n\n      this._size++;\n    }\n\n    last(n = 1) {\n      let node = this.tail;\n\n      while (--n) {\n        if (!node.prev) break;\n        node = node.prev;\n      }\n\n      return node.data;\n    }\n\n  }\n\n  const {\n    cos,\n    sin,\n    sqrt,\n    atan2,\n    pow,\n    PI\n  } = Math;\n  const DEG = PI / 180;\n\n  function polygon(option, fn) {\n    if (typeof arguments[0] == 'function') {\n      fn = option;\n      option = {};\n    }\n\n    if (!fn) {\n      fn = t => [cos(t), sin(t)];\n    }\n\n    let split = option.split || 120;\n    let scale = option.scale || 1;\n    let start = DEG * (option.start || 0);\n    let deg = option.deg ? option.deg * DEG : PI / (split / 2);\n    let points = [];\n\n    let add_point = ([x, y], scale) => {\n      points.push(x * 50 * scale + 50 + '% ' + (y * 50 * scale + 50 + '%'));\n    };\n\n    let first, first2;\n\n    for (let i = 0; i < split; ++i) {\n      let t = start - deg * i;\n      let point = fn(t, i);\n      if (!i) first = point;\n      add_point(point, scale);\n    }\n\n    if (option.frame !== undefined) {\n      add_point(first, scale);\n      let w = (option.frame || 1) / 100;\n      if (w <= 0) w = 2 / 1000;\n\n      for (let i = 0; i < split; ++i) {\n        let t = start + deg * i;\n        let [x, y] = fn(t, i);\n        let theta = atan2(y, x);\n        let point = [x - w * cos(theta), y - w * sin(theta)];\n        if (!i) first2 = point;\n        add_point(point, scale);\n      }\n\n      add_point(first2, scale);\n      add_point(first, scale);\n    }\n\n    option.type = read_fillrule(option['fill-rule']);\n    return option.type ? `polygon(${option.type}, ${points.join(',')})` : `polygon(${points.join(',')})`;\n  }\n\n  function read_fillrule(value) {\n    return value === 'nonzero' || value == 'evenodd' ? value : '';\n  }\n\n  function rotate(x, y, deg) {\n    let rad = DEG * deg;\n    return [x * cos(rad) - y * sin(rad), y * cos(rad) + x * sin(rad)];\n  }\n\n  function translate(x, y, offset) {\n    let [dx, dy = dx] = String(offset).split(/[,\\s]/).map(Number);\n    return [x + (dx || 0), y + (dy || 0)];\n  }\n\n  const shapes = {\n    circle() {\n      return 'circle(49%)';\n    },\n\n    triangle() {\n      return polygon({\n        split: 3,\n        start: -90\n      }, t => [cos(t) * 1.1, sin(t) * 1.1 + .2]);\n    },\n\n    rhombus() {\n      return polygon({\n        split: 4\n      });\n    },\n\n    pentagon() {\n      return polygon({\n        split: 5,\n        start: 54\n      });\n    },\n\n    hexgon() {\n      return polygon({\n        split: 6,\n        start: 30\n      });\n    },\n\n    hexagon() {\n      return polygon({\n        split: 6,\n        start: 30\n      });\n    },\n\n    heptagon() {\n      return polygon({\n        split: 7,\n        start: -90\n      });\n    },\n\n    octagon() {\n      return polygon({\n        split: 8,\n        start: 22.5\n      });\n    },\n\n    star() {\n      return polygon({\n        split: 5,\n        start: 54,\n        deg: 144\n      });\n    },\n\n    diamond() {\n      return 'polygon(50% 5%, 80% 50%, 50% 95%, 20% 50%)';\n    },\n\n    cross() {\n      return `polygon(\n      5% 35%,  35% 35%, 35% 5%,  65% 5%,\n      65% 35%, 95% 35%, 95% 65%, 65% 65%,\n      65% 95%, 35% 95%, 35% 65%, 5% 65%\n    )`;\n    },\n\n    clover(k = 3) {\n      k = clamp(k, 3, 5);\n      if (k == 4) k = 2;\n      return polygon({\n        split: 240\n      }, t => {\n        let x = cos(k * t) * cos(t);\n        let y = cos(k * t) * sin(t);\n        if (k == 3) x -= .2;\n\n        if (k == 2) {\n          x /= 1.1;\n          y /= 1.1;\n        }\n\n        return [x, y];\n      });\n    },\n\n    hypocycloid(k = 3) {\n      k = clamp(k, 3, 6);\n      let m = 1 - k;\n      return polygon({\n        scale: 1 / k\n      }, t => {\n        let x = m * cos(t) + cos(m * (t - PI));\n        let y = m * sin(t) + sin(m * (t - PI));\n\n        if (k == 3) {\n          x = x * 1.1 - .6;\n          y = y * 1.1;\n        }\n\n        return [x, y];\n      });\n    },\n\n    astroid() {\n      return shapes.hypocycloid(4);\n    },\n\n    infinity() {\n      return polygon(t => {\n        let a = .7 * sqrt(2) * cos(t);\n        let b = pow(sin(t), 2) + 1;\n        return [a / b, a * sin(t) / b];\n      });\n    },\n\n    heart() {\n      return polygon(t => {\n        let x = .75 * pow(sin(t), 3);\n        let y = cos(1 * t) * (13 / 18) - cos(2 * t) * (5 / 18) - cos(3 * t) / 18 - cos(4 * t) / 18;\n        return rotate(x * 1.2, (y + .2) * 1.1, 180);\n      });\n    },\n\n    bean() {\n      return polygon(t => {\n        let [a, b] = [pow(sin(t), 3), pow(cos(t), 3)];\n        return rotate((a + b) * cos(t) * 1.3 - .45, (a + b) * sin(t) * 1.3 - .45, -90);\n      });\n    },\n\n    bicorn() {\n      return polygon(t => rotate(cos(t), pow(sin(t), 2) / (2 + sin(t)) - .5, 180));\n    },\n\n    drop() {\n      return polygon(t => rotate(sin(t), (1 + sin(t)) * cos(t) / 1.4, 90));\n    },\n\n    pear() {\n      return polygon(t => [sin(t), (1 + sin(t)) * cos(t) / 1.4]);\n    },\n\n    fish() {\n      return polygon(t => [cos(t) - pow(sin(t), 2) / sqrt(2), sin(2 * t) / 2]);\n    },\n\n    whale() {\n      return polygon({\n        split: 240\n      }, t => {\n        let r = 3.4 * (pow(sin(t), 2) - .5) * cos(t);\n        return rotate(cos(t) * r + .75, sin(t) * r * 1.2, 180);\n      });\n    },\n\n    bud(n = 3) {\n      n = clamp(n, 3, 10);\n      return polygon({\n        split: 240\n      }, t => [(1 + .2 * cos(n * t)) * cos(t) * .8, (1 + .2 * cos(n * t)) * sin(t) * .8]);\n    },\n\n    alien(...args) {\n      let [a = 1, b = 1, c = 1, d = 1, e = 1] = args.map(n => clamp(n, 1, 9));\n      return polygon({\n        split: 480,\n        type: 'evenodd'\n      }, t => [(cos(t * a) + cos(t * c) + cos(t * e)) * .31, (sin(t * b) + sin(t * d) + sin(t)) * .31]);\n    }\n\n  };\n\n  function is_empty(value) {\n    return is_nil(value) || value === '';\n  }\n\n  function custom_shape(props) {\n    let option = Object.assign({}, props, {\n      split: clamp(parseInt(props.split) || 0, 3, 3600),\n      start: 0\n    });\n\n    if (props.degree) {\n      props.rotate = props.degree;\n    }\n\n    let px = is_empty(props.x) ? 'cos(t)' : props.x;\n    let py = is_empty(props.y) ? 'sin(t)' : props.y;\n    let pr = is_empty(props.r) ? '' : props.r;\n    return polygon(option, (t, i) => {\n      let context = Object.assign({}, props, {\n        't': t,\n        'θ': t,\n        'seq': (...list) => {\n          if (!list.length) return '';\n          return list[i % list.length];\n        }\n      });\n      let x = calc(px, context);\n      let y = calc(py, context);\n\n      if (pr) {\n        let r = calc(pr, context);\n        x = r * Math.cos(t);\n        y = r * Math.sin(t);\n      }\n\n      if (props.rotate) {\n        [x, y] = rotate(x, y, Number(props.rotate) || 0);\n      }\n\n      if (props.origin) {\n        [x, y] = translate(x, y, props.origin);\n      }\n\n      return [x, y];\n    });\n  }\n\n  function is_seperator(c, no_space) {\n    if (no_space) return /[,，]/.test(c);else return /[,，\\s]/.test(c);\n  }\n\n  function skip_seperator(it, no_space) {\n    while (!it.end()) {\n      if (!is_seperator(it.curr(1), no_space)) break;else it.next();\n    }\n  }\n\n  function parse$3(input, no_space = false) {\n    if (is_nil(input)) input = '';\n    const it = iterator(String(input));\n    const result = [],\n          stack = [];\n    let group = '';\n\n    while (!it.end()) {\n      let c = it.curr();\n      if (c === undefined) break;\n\n      if (c == '(') {\n        group += c;\n        stack.push(c);\n      } else if (c == ')') {\n        group += c;\n\n        if (stack.length) {\n          stack.pop();\n        }\n      } else if (stack.length) {\n        group += c;\n      } else if (is_seperator(c, no_space)) {\n        result.push(group);\n        group = '';\n        skip_seperator(it, no_space);\n      } else {\n        group += c;\n      }\n\n      it.next();\n    }\n\n    if (!is_nil(group)) {\n      result.push(group);\n    }\n\n    return result;\n  }\n\n  function parse$4(input) {\n    const it = iterator(input);\n    let temp = '';\n    let result = {};\n    let key = '';\n    let value = '';\n\n    while (!it.end()) {\n      let c = it.curr();\n\n      if (c == '/' && it.curr(1) == '*') {\n        read_comments$1(it);\n      } else if (c == ':') {\n        key = temp;\n        temp = '';\n      } else if (c == ';') {\n        value = temp;\n        key = key.trim();\n        value = value.trim();\n\n        if (key.length && value.length) {\n          result[key] = value;\n        }\n\n        key = value = temp = '';\n      } else {\n        temp += c;\n      }\n\n      it.next();\n    }\n\n    key = key.trim();\n    temp = temp.trim();\n\n    if (key.length && temp.length) {\n      result[key] = temp;\n    }\n\n    return result;\n  }\n\n  function read_comments$1(it, flag = {}) {\n    it.next();\n\n    while (!it.end()) {\n      let c = it.curr();\n\n      if ((c = it.curr()) == '*' && it.curr(1) == '/') {\n        it.next();\n        it.next();\n        break;\n      }\n\n      it.next();\n    }\n  }\n\n  const uniform_time = {\n    'name': 'cssd-uniform-time',\n    'animation-name': 'cssd-uniform-time-animation',\n    'animation-duration': '31536000000',\n\n    /* one year in ms */\n    'animation-iteration-count': 'infinite',\n    'animation-delay': '0s',\n    'animation-direction': 'normal',\n    'animation-fill-mode': 'none',\n    'animation-play-state': 'running',\n    'animation-timing-function': 'linear'\n  };\n  uniform_time['animation'] = `\n  ${uniform_time['animation-duration']}ms\n  ${uniform_time['animation-timing-function']}\n  ${uniform_time['animation-delay']}\n  ${uniform_time['animation-iteration-count']}\n  ${uniform_time['animation-name']}\n`;\n\n  function get_exposed(random) {\n    const {\n      shuffle\n    } = List(random);\n    const {\n      pick,\n      rand,\n      nrand,\n      unique_id\n    } = random_func(random);\n    const Expose = {\n      index({\n        count\n      }) {\n        return _ => count;\n      },\n\n      row({\n        y\n      }) {\n        return _ => y;\n      },\n\n      col({\n        x\n      }) {\n        return _ => x;\n      },\n\n      depth({\n        z\n      }) {\n        return _ => z;\n      },\n\n      size({\n        grid\n      }) {\n        return _ => grid.count;\n      },\n\n      ['size-row']({\n        grid\n      }) {\n        return _ => grid.y;\n      },\n\n      ['size-col']({\n        grid\n      }) {\n        return _ => grid.x;\n      },\n\n      ['size-depth']({\n        grid\n      }) {\n        return _ => grid.z;\n      },\n\n      id({\n        x,\n        y,\n        z\n      }) {\n        return _ => cell_id(x, y, z);\n      },\n\n      n({\n        extra\n      }) {\n        return _ => extra ? extra[0] : '@n';\n      },\n\n      nx({\n        extra\n      }) {\n        return _ => extra ? extra[1] : '@nx';\n      },\n\n      ny({\n        extra\n      }) {\n        return _ => extra ? extra[2] : '@ny';\n      },\n\n      N({\n        extra\n      }) {\n        return _ => extra ? extra[3] : '@N';\n      },\n\n      repeat: make_sequence(''),\n      multiple: make_sequence(','),\n      ['multiple-with-space']: make_sequence(' '),\n\n      pick({\n        context\n      }) {\n        return expand$1((...args) => {\n          return push_stack(context, 'last_pick', pick(args));\n        });\n      },\n\n      ['pick-n']({\n        context,\n        extra,\n        position\n      }) {\n        let counter = 'pn-counter' + position;\n        return expand$1((...args) => {\n          if (!context[counter]) context[counter] = 0;\n          context[counter] += 1;\n          let max = args.length;\n          let [idx] = extra || [];\n          let pos = ((idx === undefined ? context[counter] : idx) - 1) % max;\n          let value = args[pos];\n          return push_stack(context, 'last_pick', value);\n        });\n      },\n\n      ['pick-d']({\n        context,\n        extra,\n        position\n      }) {\n        let counter = 'pd-counter' + position;\n        let values = 'pd-values' + position;\n        return expand$1((...args) => {\n          if (!context[counter]) context[counter] = 0;\n          context[counter] += 1;\n\n          if (!context[values]) {\n            context[values] = shuffle(args);\n          }\n\n          let max = args.length;\n          let [idx] = extra || [];\n          let pos = ((idx === undefined ? context[counter] : idx) - 1) % max;\n          let value = context[values][pos];\n          return push_stack(context, 'last_pick', value);\n        });\n      },\n\n      ['last-pick']({\n        context\n      }) {\n        return (n = 1) => {\n          let stack = context.last_pick;\n          return stack ? stack.last(n) : '';\n        };\n      },\n\n      rand({\n        context\n      }) {\n        return (...args) => {\n          let transform_type = args.every(is_letter) ? by_charcode : by_unit;\n          let value = transform_type(rand).apply(null, args);\n          return push_stack(context, 'last_rand', value);\n        };\n      },\n\n      nrand({\n        context\n      }) {\n        return (...args) => {\n          let transform_type = args.every(is_letter) ? by_charcode : by_unit;\n          let value = transform_type(nrand).apply(null, args);\n          return push_stack(context, 'last_rand', value);\n        };\n      },\n\n      ['rand-int']({\n        context\n      }) {\n        return (...args) => {\n          let transform_type = args.every(is_letter) ? by_charcode : by_unit;\n\n          let rand_int = (...args) => Math.round(rand(...args));\n\n          let value = transform_type(rand_int).apply(null, args);\n          return push_stack(context, 'last_rand', value);\n        };\n      },\n\n      ['nrand-int']({\n        context\n      }) {\n        return (...args) => {\n          let transform_type = args.every(is_letter) ? by_charcode : by_unit;\n\n          let nrand_int = (...args) => Math.round(nrand(...args));\n\n          let value = transform_type(nrand_int).apply(null, args);\n          return push_stack(context, 'last_rand', value);\n        };\n      },\n\n      ['last-rand']({\n        context\n      }) {\n        return (n = 1) => {\n          let stack = context.last_rand;\n          return stack ? stack.last(n) : '';\n        };\n      },\n\n      stripe() {\n        return (...input) => {\n          let colors = input.map(get_value);\n          let max = colors.length;\n          let default_count = 0;\n          let custom_sizes = [];\n          let prev;\n\n          if (!max) {\n            return '';\n          }\n\n          colors.forEach(step => {\n            let [_, size] = parse$3(step);\n            if (size !== undefined) custom_sizes.push(size);else default_count += 1;\n          });\n          let default_size = custom_sizes.length ? `(100% - ${custom_sizes.join(' - ')}) / ${default_count}` : `100% / ${max}`;\n          return colors.map((step, i) => {\n            if (custom_sizes.length) {\n              let [color, size] = parse$3(step);\n              let prefix = prev ? prev + ' + ' : '';\n              prev = prefix + (size !== undefined ? size : default_size);\n              return `${color} 0 calc(${prev})`;\n            }\n\n            return `${step} 0 ${100 / max * (i + 1)}%`;\n          }).join(',');\n        };\n      },\n\n      calc() {\n        return value => calc(get_value(value));\n      },\n\n      hex() {\n        return value => parseInt(get_value(value)).toString(16);\n      },\n\n      svg: lazy(input => {\n        if (input === undefined) return '';\n        let svg = normalize_svg(get_value(input()).trim());\n        return create_svg_url(svg);\n      }),\n      ['svg-filter']: lazy(input => {\n        if (input === undefined) return '';\n        let id = unique_id('filter-');\n        let svg = normalize_svg(get_value(input()).trim()).replace(/<filter([\\s>])/, `<filter id=\"${id}\"$1`);\n        return create_svg_url(svg, id);\n      }),\n\n      var() {\n        return value => `var(${get_value(value)})`;\n      },\n\n      t() {\n        return value => `var(--${uniform_time.name})`;\n      },\n\n      shape() {\n        return memo('shape-function', (type = '', ...args) => {\n          type = String(type).trim();\n          if (!type.length) return 'polygon()';\n\n          if (typeof shapes[type] === 'function') {\n            return shapes[type](args);\n          } else {\n            let commands = type;\n            let rest = args.join(',');\n\n            if (rest.length) {\n              commands = type + ',' + rest;\n            }\n\n            let config = parse$4(commands);\n            return custom_shape(config);\n          }\n        });\n      },\n\n      doodle() {\n        return value => value;\n      },\n\n      shaders() {\n        return value => value;\n      },\n\n      path() {\n        return value => value;\n      }\n\n    };\n\n    function make_sequence(c) {\n      return lazy((n, action) => {\n        if (!action || !n) return '';\n        let count = get_value(n());\n        return sequence(count, (i, x, y, max) => get_value(action(i, x, y, max))).join(c);\n      });\n    }\n\n    function push_stack(context, name, value) {\n      if (!context[name]) context[name] = new Stack();\n      context[name].push(value);\n      return value;\n    }\n\n    return alias_for(Expose, {\n      'm': 'multiple',\n      'M': 'multiple-with-space',\n      'r': 'rand',\n      'rn': 'nrand',\n      'ri': 'rand-int',\n      'rni': 'nrand-int',\n      'lr': 'last-rand',\n      'p': 'pick',\n      'pn': 'pick-n',\n      'pd': 'pick-d',\n      'lp': 'last-pick',\n      'rep': 'repeat',\n      'i': 'index',\n      'x': 'col',\n      'y': 'row',\n      'z': 'depth',\n      'I': 'size',\n      'X': 'size-col',\n      'Y': 'size-row',\n      'Z': 'size-depth',\n      // legacy names\n      'nr': 'rn',\n      'nri': 'nri',\n      'ms': 'multiple-with-space',\n      's': 'size',\n      'sx': 'size-col',\n      'sy': 'size-row',\n      'sz': 'size-depth',\n      'size-x': 'size-col',\n      'size-y': 'size-row',\n      'size-z': 'size-depth',\n      'multi': 'multiple',\n      'pick-by-turn': 'pick-n',\n      'max-row': 'size-row',\n      'max-col': 'size-col',\n      // error prone\n      'stripes': 'stripe',\n      'strip': 'stripe'\n    });\n  }\n\n  let all = [];\n\n  function get_props(arg) {\n    if (!all.length) {\n      let props = new Set();\n\n      for (let n in document.head.style) {\n        if (!n.startsWith('-')) {\n          props.add(n.replace(/[A-Z]/g, '-$&').toLowerCase());\n        }\n      }\n\n      if (!props.has('grid-gap')) {\n        props.add('grid-gap');\n      }\n\n      all = Array.from(props);\n    }\n\n    return arg && arg.test ? all.filter(n => arg.test(n)) : all;\n  }\n\n  function build_mapping(prefix) {\n    let reg = new RegExp(`\\\\-?${prefix}\\\\-?`);\n    return get_props(reg).map(n => n.replace(reg, '')).reduce((obj, n) => {\n      return obj[n] = n, obj;\n    }, {});\n  }\n\n  const props_webkit_mapping = build_mapping('webkit');\n  const props_moz_mapping = build_mapping('moz');\n\n  function prefixer(prop, rule) {\n    if (props_webkit_mapping[prop]) {\n      return `-webkit-${rule} ${rule}`;\n    } else if (props_moz_mapping[prop]) {\n      return `-moz-${rule} ${rule}`;\n    }\n\n    return rule;\n  }\n\n  const presets = {\n    '4a0': [1682, 2378],\n    '2a0': [1189, 1682],\n    a0: [841, 1189],\n    a1: [594, 841],\n    a2: [420, 594],\n    a3: [297, 420],\n    a4: [210, 297],\n    a5: [148, 210],\n    a6: [105, 148],\n    a7: [74, 105],\n    a8: [52, 74],\n    a9: [37, 52],\n    a10: [26, 37],\n    b0: [1000, 1414],\n    b1: [707, 1000],\n    b2: [500, 707],\n    b3: [353, 500],\n    b4: [250, 353],\n    b5: [176, 250],\n    b6: [125, 176],\n    b7: [88, 125],\n    b8: [62, 88],\n    b9: [44, 62],\n    b10: [31, 44],\n    b11: [22, 32],\n    b12: [16, 22],\n    c0: [917, 1297],\n    c1: [648, 917],\n    c2: [458, 648],\n    c3: [324, 458],\n    c4: [229, 324],\n    c5: [162, 229],\n    c6: [114, 162],\n    c7: [81, 114],\n    c8: [57, 81],\n    c9: [40, 57],\n    c10: [28, 40],\n    c11: [22, 32],\n    c12: [16, 22],\n    d0: [764, 1064],\n    d1: [532, 760],\n    d2: [380, 528],\n    d3: [264, 376],\n    d4: [188, 260],\n    d5: [130, 184],\n    d6: [92, 126],\n    letter: [216, 279],\n    legal: [216, 356],\n    'junior-legal': [203, 127],\n    ledger: [279, 432],\n    tabloid: [279, 432],\n    executive: [190, 254],\n    postcard: [100, 148],\n    'business-card': [54, 90],\n    poster: [390, 540]\n  };\n  const modes = {\n    portrait: 'p',\n    pt: 'p',\n    p: 'p',\n    landscape: 'l',\n    ls: 'l',\n    l: 'l'\n  };\n  const unit = 'mm';\n\n  function get_preset(name, mode) {\n    name = String(name).toLowerCase(); // Default to landscape mode\n\n    let [h, w] = presets[name] || [];\n\n    if (modes[mode] == 'p') {\n      [w, h] = [h, w];\n    }\n\n    return [w, h].map(n => n + unit);\n  }\n\n  function is_preset(name) {\n    return !!presets[name];\n  }\n\n  var Property = {\n    ['@size'](value, {\n      is_special_selector\n    }) {\n      let [w, h = w] = parse$3(value);\n\n      if (is_preset(w)) {\n        [w, h] = get_preset(w, h);\n      }\n\n      return `\n      width: ${w};\n      height: ${h};\n      ${is_special_selector ? '' : `\n        --internal-cell-width: ${w};\n        --internal-cell-height: ${h};\n      `}\n    `;\n    },\n\n    ['@min-size'](value) {\n      let [w, h = w] = parse$3(value);\n      return `min-width: ${w}; min-height: ${h};`;\n    },\n\n    ['@max-size'](value) {\n      let [w, h = w] = parse$3(value);\n      return `max-width: ${w}; max-height: ${h};`;\n    },\n\n    ['@place-cell']: (() => {\n      let map_left_right = {\n        'center': '50%',\n        '0': '0%',\n        'left': '0%',\n        'right': '100%',\n        'top': '50%',\n        'bottom': '50%'\n      };\n      let map_top_bottom = {\n        'center': '50%',\n        '0': '0%',\n        'top': '0%',\n        'bottom': '100%',\n        'left': '50%',\n        'right': '50%'\n      };\n      return value => {\n        let [left, top = '50%'] = parse$3(value);\n        left = map_left_right[left] || left;\n        top = map_top_bottom[top] || top;\n        const cw = 'var(--internal-cell-width, 25%)';\n        const ch = 'var(--internal-cell-height, 25%)';\n        return `\n        position: absolute;\n        left: ${left};\n        top: ${top};\n        width: ${cw};\n        height: ${ch};\n        margin-left: calc(${cw} / -2) !important;\n        margin-top: calc(${ch} / -2) !important;\n        grid-area: unset !important;\n      `;\n      };\n    })(),\n\n    ['@grid'](value, options) {\n      let [grid, ...size] = value.split('/').map(s => s.trim());\n      size = size.join(' / ');\n      return {\n        grid: parse_grid(grid),\n        size: size ? this['@size'](size, options) : ''\n      };\n    },\n\n    ['@shape']: memo('shape-property', value => {\n      let [type, ...args] = parse$3(value);\n      let prop = 'clip-path';\n      if (typeof shapes[type] !== 'function') return '';\n      let rules = `${prop}: ${shapes[type](...args)};`;\n      return prefixer(prop, rules) + 'overflow: hidden;';\n    }),\n\n    ['@use'](rules) {\n      if (rules.length > 2) {\n        return rules;\n      }\n    }\n\n  };\n\n  function build_expr(expr) {\n    return n => String(expr).replace(/(\\d+)(n)/g, '$1*' + n).replace(/n/g, n);\n  }\n\n  function nth(input, curr, max) {\n    let expr = build_expr(input);\n\n    for (let i = 0; i <= max; ++i) {\n      if (calc(expr(i)) == curr) return true;\n    }\n  }\n\n  const is$1 = {\n    even: n => !(n % 2),\n    odd: n => !!(n % 2)\n  };\n\n  function even_or_odd(expr) {\n    return /^(even|odd)$/.test(expr);\n  }\n\n  function Selector(random) {\n    return {\n      at({\n        x,\n        y\n      }) {\n        return (x1, y1) => x == x1 && y == y1;\n      },\n\n      nth({\n        count,\n        grid\n      }) {\n        return (...exprs) => exprs.some(expr => even_or_odd(expr) ? is$1[expr](count) : nth(expr, count, grid.count));\n      },\n\n      row({\n        y,\n        grid\n      }) {\n        return (...exprs) => exprs.some(expr => even_or_odd(expr) ? is$1[expr](y) : nth(expr, y, grid.y));\n      },\n\n      col({\n        x,\n        grid\n      }) {\n        return (...exprs) => exprs.some(expr => even_or_odd(expr) ? is$1[expr](x) : nth(expr, x, grid.x));\n      },\n\n      even({\n        count,\n        grid,\n        y\n      }) {\n        return arg => {\n          if (arg === 'cross' && is$1.even(grid.x)) {\n            let m = is$1.even(y) ? 'odd' : 'even';\n            return is$1[m](count);\n          } else {\n            return is$1.even(count);\n          }\n        };\n      },\n\n      odd({\n        count,\n        grid,\n        y\n      }) {\n        return arg => {\n          if (arg === 'cross' && is$1.even(grid.x)) {\n            let m = is$1.even(y) ? 'even' : 'odd';\n            return is$1[m](count);\n          } else {\n            return is$1.odd(count);\n          }\n        };\n      },\n\n      random() {\n        return (ratio = .5) => {\n          if (ratio >= 1 && ratio <= 0) ratio = .5;\n          return random() < ratio;\n        };\n      }\n\n    };\n  } // Expose all Math functions and constants.\n\n\n  const methods = Object.getOwnPropertyNames(Math);\n  var MathFunc = methods.reduce((expose, n) => {\n    expose[n] = () => (...args) => {\n      args = args.map(get_value);\n      if (typeof Math[n] === 'number') return Math[n];\n      return Math[n].apply(null, args.map(calc));\n    };\n\n    return expose;\n  }, {});\n  const initial = {\n    length: '0px',\n    number: 0,\n    color: 'black',\n    url: 'url()',\n    image: 'url()',\n    integer: 0,\n    angle: '0deg',\n    time: '0ms',\n    resolution: '0dpi',\n    percentage: '0%',\n    'length-percentage': '0%',\n    'transform-function': 'translate(0)',\n    'transform-list': 'translate(0)',\n    'custom-ident': '_'\n  };\n\n  function get_definition(name) {\n    let type = String(name).substr(2).split('-')[0];\n\n    if (initial[type] !== undefined) {\n      return {\n        name: name,\n        syntax: `<${type}> | <${type}>+ | <${type}>#`,\n        initialValue: initial[type],\n        inherits: false\n      };\n    }\n  }\n\n  let {\n    join,\n    make_array,\n    remove_empty_values\n  } = List();\n\n  function is_host_selector(s) {\n    return /^\\:(host|doodle)/.test(s);\n  }\n\n  function is_parent_selector(s) {\n    return /^\\:(container|parent)/.test(s);\n  }\n\n  function is_special_selector(s) {\n    return is_host_selector(s) || is_parent_selector(s);\n  }\n\n  class Rules {\n    constructor(tokens, random) {\n      this.tokens = tokens;\n      this.rules = {};\n      this.props = {};\n      this.keyframes = {};\n      this.grid = null;\n      this.is_grid_defined = false;\n      this.coords = [];\n      this.doodles = {};\n      this.shaders = {};\n      this.paths = {};\n      this.reset();\n      this.Func = get_exposed(random);\n      this.Selector = Selector(random);\n      this.custom_properties = {};\n      this.uniforms = {};\n      this.unique_id = random_func(random).unique_id;\n    }\n\n    reset() {\n      this.styles = {\n        host: '',\n        container: '',\n        cells: '',\n        keyframes: ''\n      };\n      this.coords = [];\n      this.doodles = {};\n\n      for (let key in this.rules) {\n        if (key.startsWith('#c')) {\n          delete this.rules[key];\n        }\n      }\n    }\n\n    add_rule(selector, rule) {\n      let rules = this.rules[selector];\n\n      if (!rules) {\n        rules = this.rules[selector] = [];\n      }\n\n      rules.push.apply(rules, make_array(rule));\n    }\n\n    pick_func(name) {\n      return this.Func[name] || MathFunc[name];\n    }\n\n    apply_func(fn, coords, args) {\n      let _fn = fn(...make_array(coords));\n\n      let input = [];\n      args.forEach(arg => {\n        let type = typeof arg.value;\n        let is_string_or_number = type === 'number' || type === 'string';\n\n        if (!arg.cluster && is_string_or_number) {\n          input.push(...parse$3(arg.value, true));\n        } else {\n          if (typeof arg === 'function') {\n            input.push(arg);\n          } else if (!is_nil(arg.value)) {\n            let value = get_value(arg.value);\n            input.push(value);\n          }\n        }\n      });\n      input = remove_empty_values(input);\n\n      let result = _fn(...make_array(input));\n\n      return result;\n    }\n\n    compose_aname(...args) {\n      return args.join('-');\n    }\n\n    compose_selector({\n      x,\n      y,\n      z\n    }, pseudo = '') {\n      return `#${cell_id(x, y, z)}${pseudo}`;\n    }\n\n    is_composable(name) {\n      return ['doodle', 'shaders'].includes(name);\n    }\n\n    compose_argument(argument, coords, extra = []) {\n      let result = argument.map(arg => {\n        if (arg.type === 'text') {\n          return arg.value;\n        } else if (arg.type === 'func') {\n          let fname = arg.name.substr(1);\n          let fn = this.pick_func(fname);\n\n          if (typeof fn === 'function') {\n            if (fname === 't') {\n              this.uniforms.time = true;\n            }\n\n            if (this.is_composable(fname)) {\n              let value = get_value((arg.arguments[0] || [])[0]);\n\n              if (!is_nil(value)) {\n                switch (fname) {\n                  case 'doodle':\n                    return this.compose_doodle(value);\n\n                  case 'shaders':\n                    return this.compose_shaders(value, coords);\n                }\n              }\n            }\n\n            coords.extra = extra;\n            coords.position = arg.position;\n            let args = arg.arguments.map(n => {\n              return fn.lazy ? (...extra) => this.compose_argument(n, coords, extra) : this.compose_argument(n, coords, extra);\n            });\n            let value = this.apply_func(fn, coords, args);\n\n            if (fname == 'path') {\n              return this.compose_path(value);\n            }\n\n            return value;\n          }\n        }\n      });\n      return {\n        cluster: argument.cluster,\n        value: result.length >= 2 ? {\n          value: result.join('')\n        } : result[0]\n      };\n    }\n\n    compose_doodle(doodle) {\n      let id = this.unique_id('doodle');\n      this.doodles[id] = doodle;\n      return '${' + id + '}';\n    }\n\n    compose_shaders(shader, {\n      x,\n      y,\n      z\n    }) {\n      let id = this.unique_id('shader');\n      this.shaders[id] = {\n        shader,\n        cell: cell_id(x, y, z)\n      };\n      return '${' + id + '}';\n    }\n\n    compose_path(commands) {\n      let id = this.unique_id('path');\n      this.paths[id] = {\n        id,\n        commands\n      };\n      return '${' + id + '}';\n    }\n\n    compose_value(value, coords) {\n      if (!Array.isArray(value)) {\n        return '';\n      }\n\n      return value.reduce((result, val) => {\n        switch (val.type) {\n          case 'text':\n            {\n              result += val.value;\n              break;\n            }\n\n          case 'func':\n            {\n              let fname = val.name.substr(1);\n              let fn = this.pick_func(fname);\n\n              if (typeof fn === 'function') {\n                if (fname === 't') {\n                  this.uniforms.time = true;\n                }\n\n                if (this.is_composable(fname)) {\n                  let value = get_value((val.arguments[0] || [])[0]);\n\n                  if (!is_nil(value)) {\n                    switch (fname) {\n                      case 'doodle':\n                        result += this.compose_doodle(value);\n                        break;\n\n                      case 'shaders':\n                        result += this.compose_shaders(value, coords);\n                        break;\n                    }\n                  }\n                } else {\n                  coords.position = val.position;\n                  let args = val.arguments.map(arg => {\n                    return fn.lazy ? (...extra) => this.compose_argument(arg, coords, extra) : this.compose_argument(arg, coords);\n                  });\n                  let output = this.apply_func(fn, coords, args);\n\n                  if (!is_nil(output)) {\n                    if (fname == 'path') {\n                      result += this.compose_path(output);\n                    } else {\n                      result += output;\n                    }\n                  }\n                }\n              }\n            }\n        }\n\n        return result;\n      }, '');\n    }\n\n    compose_rule(token, _coords, selector) {\n      let coords = Object.assign({}, _coords);\n      let prop = token.property;\n      let value_group = token.value.reduce((ret, v) => {\n        let composed = this.compose_value(v, coords);\n        if (composed) ret.push(composed);\n        return ret;\n      }, []);\n      let value = value_group.join(', ');\n\n      if (/^animation(\\-name)?$/.test(prop)) {\n        this.props.has_animation = true;\n\n        if (is_host_selector(selector)) {\n          let prefix = uniform_time[prop];\n\n          if (prefix && value) {\n            value = prefix + ',' + value;\n          }\n        }\n\n        if (coords.count > 1) {\n          let {\n            count\n          } = coords;\n\n          switch (prop) {\n            case 'animation-name':\n              {\n                value = value_group.map(n => this.compose_aname(n, count)).join(', ');\n                break;\n              }\n\n            case 'animation':\n              {\n                value = value_group.map(n => {\n                  let group = (n || '').split(/\\s+/);\n                  group[0] = this.compose_aname(group[0], count);\n                  return group.join(' ');\n                }).join(', ');\n              }\n          }\n        }\n      }\n\n      if (prop === 'content') {\n        if (!/[\"']|^none$|^(var|counter|counters|attr)\\(/.test(value)) {\n          value = `'${value}'`;\n        }\n      }\n\n      if (prop === 'transition') {\n        this.props.has_transition = true;\n      }\n\n      let rule = `${prop}: ${value};`;\n      rule = prefixer(prop, rule);\n\n      if (prop === 'clip-path') {\n        // fix clip bug\n        rule += ';overflow: hidden;';\n      }\n\n      if (prop === 'width' || prop === 'height') {\n        if (!is_special_selector(selector)) {\n          rule += `--internal-cell-${prop}: ${value};`;\n        }\n      }\n\n      if (prop === 'background' && value.includes('shader')) {\n        rule += 'background-size: 100% 100%;';\n      }\n\n      if (/^\\-\\-/.test(prop)) {\n        this.custom_properties[prop] = value;\n      }\n\n      if (Property[prop]) {\n        let transformed = Property[prop](value, {\n          is_special_selector: is_special_selector(selector)\n        });\n\n        switch (prop) {\n          case '@grid':\n            {\n              if (is_host_selector(selector)) {\n                rule = transformed.size || '';\n              } else {\n                rule = '';\n\n                if (!this.is_grid_defined) {\n                  transformed = Property[prop](value, {\n                    is_special_selector: true\n                  });\n                  this.add_rule(':host', transformed.size || '');\n                }\n              }\n\n              this.grid = coords.grid;\n              this.is_grid_defined = true;\n              break;\n            }\n\n          case '@place-cell':\n            {\n              if (!is_host_selector(selector)) {\n                rule = transformed;\n              }\n\n              break;\n            }\n\n          case '@use':\n            {\n              if (token.value.length) {\n                this.compose(coords, token.value);\n              }\n\n              rule = '';\n              break;\n            }\n\n          default:\n            {\n              rule = transformed;\n            }\n        }\n      }\n\n      return rule;\n    }\n\n    pre_compose_rule(token, _coords) {\n      let coords = Object.assign({}, _coords);\n      let prop = token.property;\n\n      switch (prop) {\n        case '@grid':\n          {\n            let value_group = token.value.reduce((ret, v) => {\n              let composed = this.compose_value(v, coords);\n              if (composed) ret.push(composed);\n              return ret;\n            }, []);\n            let value = value_group.join(', ');\n            let transformed = Property[prop](value, {});\n            this.grid = transformed.grid;\n            break;\n          }\n\n        case '@use':\n          {\n            if (token.value.length) {\n              this.pre_compose(coords, token.value);\n            }\n\n            break;\n          }\n      }\n    }\n\n    pre_compose(coords, tokens) {\n      (tokens || this.tokens).forEach(token => {\n        switch (token.type) {\n          case 'rule':\n            {\n              this.pre_compose_rule(token, coords);\n              break;\n            }\n\n          case 'pseudo':\n            {\n              if (is_host_selector(token.selector)) {\n                (token.styles || []).forEach(token => {\n                  this.pre_compose_rule(token, coords);\n                });\n              }\n\n              break;\n            }\n        }\n      });\n    }\n\n    compose(coords, tokens, initial) {\n      this.coords.push(coords);\n      (tokens || this.tokens).forEach((token, i) => {\n        if (token.skip) return false;\n        if (initial && this.grid) return false;\n\n        switch (token.type) {\n          case 'rule':\n            {\n              this.add_rule(this.compose_selector(coords), this.compose_rule(token, coords));\n              break;\n            }\n\n          case 'pseudo':\n            {\n              if (token.selector.startsWith(':doodle')) {\n                token.selector = token.selector.replace(/^\\:+doodle/, ':host');\n              }\n\n              let special = is_special_selector(token.selector);\n\n              if (special) {\n                token.skip = true;\n              }\n\n              token.selector.split(',').forEach(selector => {\n                let pseudo = token.styles.map(s => this.compose_rule(s, coords, selector));\n                let composed = special ? selector : this.compose_selector(coords, selector);\n                this.add_rule(composed, pseudo);\n              });\n              break;\n            }\n\n          case 'cond':\n            {\n              let fn = this.Selector[token.name.substr(1)];\n\n              if (fn) {\n                let args = token.arguments.map(arg => {\n                  return this.compose_argument(arg, coords);\n                });\n                let result = this.apply_func(fn, coords, args);\n\n                if (result) {\n                  this.compose(coords, token.styles);\n                }\n              }\n\n              break;\n            }\n\n          case 'keyframes':\n            {\n              if (!this.keyframes[token.name]) {\n                this.keyframes[token.name] = coords => `\n              ${join(token.steps.map(step => `\n                ${step.name} {\n                  ${join(step.styles.map(s => this.compose_rule(s, coords)))}\n                }\n              `))}\n            `;\n              }\n            }\n        }\n      });\n    }\n\n    output() {\n      Object.keys(this.rules).forEach((selector, i) => {\n        if (is_parent_selector(selector)) {\n          this.styles.container += `\n          .container {\n            ${join(this.rules[selector])}\n          }\n        `;\n        } else {\n          let target = is_host_selector(selector) ? 'host' : 'cells';\n          let value = join(this.rules[selector]).trim();\n          let name = target === 'host' ? `${selector}, .host` : selector;\n          this.styles[target] += `${name} { ${value} }`;\n        }\n      });\n      let keyframes = Object.keys(this.keyframes);\n\n      if (this.uniforms.time) {\n        this.styles.container += `\n        :host, .host {\n          animation: ${uniform_time.animation};\n        }\n      `;\n        this.styles.keyframes += `\n       @keyframes ${uniform_time['animation-name']} {\n         from { --${uniform_time.name}: 0 }\n         to { --${uniform_time.name}: ${uniform_time['animation-duration']} }\n       }\n      `;\n      }\n\n      this.coords.forEach((coords, i) => {\n        keyframes.forEach(name => {\n          let aname = this.compose_aname(name, coords.count);\n          this.styles.keyframes += `\n          ${maybe(i === 0, `@keyframes ${name} {\n              ${this.keyframes[name](coords)}\n            }`)}\n          @keyframes ${aname} {\n            ${this.keyframes[name](coords)}\n          }\n        `;\n        });\n      });\n      let definitions = [];\n      Object.keys(this.custom_properties).forEach(name => {\n        let def = get_definition(name);\n\n        if (def) {\n          definitions.push(def);\n        }\n      });\n      return {\n        props: this.props,\n        styles: this.styles,\n        grid: this.grid,\n        doodles: this.doodles,\n        shaders: this.shaders,\n        paths: this.paths,\n        definitions: definitions,\n        uniforms: this.uniforms\n      };\n    }\n\n  }\n\n  function generator(tokens, grid_size, random) {\n    let rules = new Rules(tokens, random);\n    let context = {};\n    rules.pre_compose({\n      x: 1,\n      y: 1,\n      z: 1,\n      count: 1,\n      context: {},\n      grid: {\n        x: 1,\n        y: 1,\n        z: 1,\n        count: 1\n      }\n    });\n    let {\n      grid\n    } = rules.output();\n    if (grid) grid_size = grid;\n    rules.reset();\n\n    if (grid_size.z == 1) {\n      for (let y = 1, count = 0; y <= grid_size.y; ++y) {\n        for (let x = 1; x <= grid_size.x; ++x) {\n          rules.compose({\n            x,\n            y,\n            z: 1,\n            count: ++count,\n            grid: grid_size,\n            context\n          });\n        }\n      }\n    } else {\n      for (let z = 1, count = 0; z <= grid_size.z; ++z) {\n        rules.compose({\n          x: 1,\n          y: 1,\n          z,\n          count: ++count,\n          grid: grid_size,\n          context\n        });\n      }\n    }\n\n    return rules.output();\n  }\n  /*\n  Copyright 2019 David Bau.\n  Permission is hereby granted, free of charge, to any person obtaining\n  a copy of this software and associated documentation files (the\n  \"Software\"), to deal in the Software without restriction, including\n  without limitation the rights to use, copy, modify, merge, publish,\n  distribute, sublicense, and/or sell copies of the Software, and to\n  permit persons to whom the Software is furnished to do so, subject to\n  the following conditions:\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n  */\n\n\n  var global = window;\n  var math = Math;\n  var pool = []; //\n  // The following constants are related to IEEE 754 limits.\n  //\n\n  var width = 256,\n      // each RC4 output is 0 <= x < 256\n  chunks = 6,\n      // at least six RC4 outputs for each double\n  digits = 52,\n      // there are 52 significant digits in a double\n  rngname = 'random',\n      // rngname: name for Math.random and Math.seedrandom\n  startdenom = math.pow(width, chunks),\n      significance = math.pow(2, digits),\n      overflow = significance * 2,\n      mask = width - 1,\n      nodecrypto; // node.js crypto module, initialized at the bottom.\n  //\n  // seedrandom()\n  // This is the seedrandom function described above.\n  //\n\n  function seedrandom(seed, options, callback) {\n    var key = [];\n    options = options == true ? {\n      entropy: true\n    } : options || {}; // Flatten the seed string or build one from local entropy if needed.\n\n    var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed, 3), key); // Use the seed to initialize an ARC4 generator.\n\n    var arc4 = new ARC4(key); // This function returns a random double in [0, 1) that contains\n    // randomness in every bit of the mantissa of the IEEE 754 value.\n\n    var prng = function () {\n      var n = arc4.g(chunks),\n          // Start with a numerator n < 2 ^ 48\n      d = startdenom,\n          //   and denominator d = 2 ^ 48.\n      x = 0; //   and no 'extra last byte'.\n\n      while (n < significance) {\n        // Fill up all significant digits by\n        n = (n + x) * width; //   shifting numerator and\n\n        d *= width; //   denominator and generating a\n\n        x = arc4.g(1); //   new least-significant-byte.\n      }\n\n      while (n >= overflow) {\n        // To avoid rounding up, before adding\n        n /= 2; //   last byte, shift everything\n\n        d /= 2; //   right using integer math until\n\n        x >>>= 1; //   we have exactly the desired bits.\n      }\n\n      return (n + x) / d; // Form the number within [0, 1).\n    };\n\n    prng.int32 = function () {\n      return arc4.g(4) | 0;\n    };\n\n    prng.quick = function () {\n      return arc4.g(4) / 0x100000000;\n    };\n\n    prng.double = prng; // Mix the randomness into accumulated entropy.\n\n    mixkey(tostring(arc4.S), pool); // Calling convention: what to return as a function of prng, seed, is_math.\n\n    return (options.pass || callback || function (prng, seed, is_math_call, state) {\n      if (state) {\n        // Load the arc4 state from the given state if it has an S array.\n        if (state.S) {\n          copy(state, arc4);\n        } // Only provide the .state method if requested via options.state.\n\n\n        prng.state = function () {\n          return copy(arc4, {});\n        };\n      } // If called as a method of Math (Math.seedrandom()), mutate\n      // Math.random because that is how seedrandom.js has worked since v1.0.\n\n\n      if (is_math_call) {\n        math[rngname] = prng;\n        return seed;\n      } // Otherwise, it is a newer calling convention, so return the\n      // prng directly.\n      else return prng;\n    })(prng, shortseed, 'global' in options ? options.global : this == math, options.state);\n  } //\n  // ARC4\n  //\n  // An ARC4 implementation.  The constructor takes a key in the form of\n  // an array of at most (width) integers that should be 0 <= x < (width).\n  //\n  // The g(count) method returns a pseudorandom integer that concatenates\n  // the next (count) outputs from ARC4.  Its return value is a number x\n  // that is in the range 0 <= x < (width ^ count).\n  //\n\n\n  function ARC4(key) {\n    var t,\n        keylen = key.length,\n        me = this,\n        i = 0,\n        j = me.i = me.j = 0,\n        s = me.S = []; // The empty key [] is treated as [0].\n\n    if (!keylen) {\n      key = [keylen++];\n    } // Set up S using the standard key scheduling algorithm.\n\n\n    while (i < width) {\n      s[i] = i++;\n    }\n\n    for (i = 0; i < width; i++) {\n      s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];\n      s[j] = t;\n    } // The \"g\" method returns the next (count) outputs as one number.\n\n\n    (me.g = function (count) {\n      // Using instance members instead of closure state nearly doubles speed.\n      var t,\n          r = 0,\n          i = me.i,\n          j = me.j,\n          s = me.S;\n\n      while (count--) {\n        t = s[i = mask & i + 1];\n        r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];\n      }\n\n      me.i = i;\n      me.j = j;\n      return r; // For robust unpredictability, the function call below automatically\n      // discards an initial batch of values.  This is called RC4-drop[256].\n      // See http://google.com/search?q=rsa+fluhrer+response&btnI\n    })(width);\n  } //\n  // copy()\n  // Copies internal state of ARC4 to or from a plain object.\n  //\n\n\n  function copy(f, t) {\n    t.i = f.i;\n    t.j = f.j;\n    t.S = f.S.slice();\n    return t;\n  } //\n  // flatten()\n  // Converts an object tree to nested arrays of strings.\n  //\n\n\n  function flatten(obj, depth) {\n    var result = [],\n        typ = typeof obj,\n        prop;\n\n    if (depth && typ == 'object') {\n      for (prop in obj) {\n        try {\n          result.push(flatten(obj[prop], depth - 1));\n        } catch (e) {}\n      }\n    }\n\n    return result.length ? result : typ == 'string' ? obj : obj + '\\0';\n  } //\n  // mixkey()\n  // Mixes a string seed into a key that is an array of integers, and\n  // returns a shortened string seed that is equivalent to the result key.\n  //\n\n\n  function mixkey(seed, key) {\n    var stringseed = seed + '',\n        smear,\n        j = 0;\n\n    while (j < stringseed.length) {\n      key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);\n    }\n\n    return tostring(key);\n  } //\n  // autoseed()\n  // Returns an object for autoseeding, using window.crypto and Node crypto\n  // module if available.\n  //\n\n\n  function autoseed() {\n    try {\n      var out;\n      if (nodecrypto && (out = nodecrypto.randomBytes)) ;else {\n        out = new Uint8Array(width);\n        (global.crypto || global.msCrypto).getRandomValues(out);\n      }\n      return tostring(out);\n    } catch (e) {\n      var browser = global.navigator,\n          plugins = browser && browser.plugins;\n      return [+new Date(), global, plugins, global.screen, tostring(pool)];\n    }\n  } //\n  // tostring()\n  // Converts an array of charcodes to a string\n  //\n\n\n  function tostring(a) {\n    return String.fromCharCode.apply(0, a);\n  } //\n  // When seedrandom.js is loaded, we immediately mix a few bits\n  // from the built-in RNG into the entropy pool.  Because we do\n  // not want to interfere with deterministic PRNG state later,\n  // seedrandom will not call math.random on its own again after\n  // initialization.\n  //\n\n\n  mixkey(math.random(), pool);\n\n  function create_shader(gl, type, source) {\n    let shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    return shader;\n  }\n\n  function create_program(gl, vss, fss) {\n    let vs = create_shader(gl, gl.VERTEX_SHADER, vss);\n    let fs = create_shader(gl, gl.FRAGMENT_SHADER, fss);\n    let prog = gl.createProgram();\n    gl.attachShader(prog, vs);\n    gl.attachShader(prog, fs);\n    gl.linkProgram(prog);\n\n    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {\n      console.warn('Link failed: ' + gl.getProgramInfoLog(prog));\n      console.warn('vs info-log: ' + gl.getShaderInfoLog(vs));\n      console.warn('fs info-log: ' + gl.getShaderInfoLog(fs));\n    }\n\n    return prog;\n  }\n\n  function add_uniform(fragment, uniform) {\n    if (!fragment.includes(uniform)) {\n      return uniform + '\\n' + fragment;\n    }\n\n    return fragment;\n  }\n\n  const fragment_head = `\n  precision highp float;\n`;\n  const default_vertex_shader = `\n  attribute vec4 position;\n  void main() {\n    gl_Position = position;\n  }\n`;\n  /* https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL */\n\n  function load_texture(gl, image, i) {\n    const texture = gl.createTexture();\n    gl.activeTexture(gl['TEXTURE' + i]);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  }\n\n  function draw_shader(shaders, width, height) {\n    let canvas = document.createElement('canvas');\n    let ratio = window.devicePixelRatio || 1;\n    width *= ratio;\n    height *= ratio;\n    canvas.width = width;\n    canvas.height = height;\n    let gl = canvas.getContext('webgl') || canvas.getContext('exprimental-webgl');\n    if (!gl) return ''; // resolution uniform\n\n    let fragment = add_uniform(shaders.fragment || '', 'uniform vec2 u_resolution;'); // texture uniform\n\n    shaders.textures.forEach(n => {\n      let uniform = `uniform sampler2D ${n.name};`;\n      fragment = add_uniform(fragment, uniform);\n    });\n    let program = create_program(gl, shaders.vertex || default_vertex_shader, fragment_head + fragment);\n    /* position in vertex shader */\n\n    let positionAttributeLocation = gl.getAttribLocation(program, 'position');\n    let positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    let vertices = [-1, -1, -1, 1, 1, -1, 1, 1, -1, 1, 1, -1];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.useProgram(program);\n    /* resolve uniforms */\n\n    gl.uniform2fv(gl.getUniformLocation(program, \"u_resolution\"), [width, height]);\n    shaders.textures.forEach((n, i) => {\n      load_texture(gl, n.value, i);\n      gl.uniform1i(gl.getUniformLocation(program, n.name), i);\n    }); // two triangles to form a rectangle\n\n    gl.drawArrays(gl.TRIANGLES, 0, 6); // resolve image data in 72dpi :(\n\n    return Promise.resolve(canvas.toDataURL());\n  }\n\n  function get_all_variables(element) {\n    let ret = {};\n\n    if (element.computedStyleMap) {\n      for (let [prop, value] of element.computedStyleMap()) {\n        if (prop.startsWith('--')) {\n          ret[prop] = value[0][0];\n        }\n      }\n    } else {\n      let styles = getComputedStyle(element);\n\n      for (let prop of styles) {\n        if (prop.startsWith('--')) {\n          ret[prop] = styles.getPropertyValue(prop);\n        }\n      }\n    }\n\n    return inline(ret);\n  }\n\n  function get_variable(element, name) {\n    return getComputedStyle(element).getPropertyValue(name).trim().replace(/^\\(|\\)$/g, '');\n  }\n\n  function inline(map) {\n    let result = [];\n\n    for (let prop in map) {\n      result.push(prop + ':' + map[prop]);\n    }\n\n    return result.join(';');\n  }\n\n  class Doodle extends HTMLElement {\n    constructor() {\n      super();\n      this.doodle = this.attachShadow({\n        mode: 'open'\n      });\n      this.extra = {\n        get_variable: name => get_variable(this, name)\n      };\n    }\n\n    connectedCallback(again) {\n      if (/^(complete|interactive|loaded)$/.test(document.readyState)) {\n        this.load(again);\n      } else {\n        setTimeout(() => this.load(again));\n      }\n    }\n\n    update(styles) {\n      let use = this.get_use();\n      if (!styles) styles = this.innerHTML;\n      this.innerHTML = styles;\n\n      if (!this.grid_size) {\n        this.grid_size = this.get_grid();\n      }\n\n      let {\n        x: gx,\n        y: gy,\n        z: gz\n      } = this.grid_size;\n      const compiled = this.generate(parse$1(use + styles, this.extra));\n\n      if (!this.shadowRoot.innerHTML) {\n        Object.assign(this.grid_size, compiled.grid);\n        return this.build_grid(compiled, compiled.grid);\n      }\n\n      if (compiled.grid) {\n        let {\n          x,\n          y,\n          z\n        } = compiled.grid;\n\n        if (gx !== x || gy !== y || gz !== z) {\n          Object.assign(this.grid_size, compiled.grid);\n          return this.build_grid(compiled, compiled.grid);\n        }\n\n        Object.assign(this.grid_size, compiled.grid);\n      } else {\n        let grid = this.get_grid();\n        let {\n          x,\n          y,\n          z\n        } = grid;\n\n        if (gx !== x || gy !== y || gz !== z) {\n          Object.assign(this.grid_size, grid);\n          return this.build_grid(this.generate(parse$1(use + styles, this.extra)), grid);\n        }\n      }\n\n      let svg_paths = this.build_svg_paths(compiled.paths);\n\n      if (svg_paths) {\n        let defs = this.shadowRoot.querySelector('.svg-defs');\n\n        if (defs) {\n          defs.innerHTML = svg_paths;\n        }\n      }\n\n      if (compiled.uniforms.time) {\n        this.register_uniform_time();\n      }\n\n      let replace = this.replace(compiled);\n      this.set_content('.style-keyframes', replace(compiled.styles.keyframes));\n\n      if (compiled.props.has_animation) {\n        this.set_content('.style-cells', '');\n        this.set_content('.style-container', '');\n      }\n\n      setTimeout(() => {\n        this.set_content('.style-container', replace(get_grid_styles(this.grid_size) + compiled.styles.host + compiled.styles.container));\n        this.set_content('.style-cells', replace(compiled.styles.cells));\n      });\n    }\n\n    get grid() {\n      return Object.assign({}, this.grid_size);\n    }\n\n    set grid(grid) {\n      this.attr('grid', grid);\n      this.connectedCallback(true);\n    }\n\n    get seed() {\n      return this._seed_value;\n    }\n\n    set seed(seed) {\n      this.attr('seed', seed);\n      this.connectedCallback(true);\n    }\n\n    get use() {\n      return this.attr('use');\n    }\n\n    set use(use) {\n      this.attr('use', use);\n      this.connectedCallback(true);\n    }\n\n    static get observedAttributes() {\n      return ['grid', 'use', 'seed'];\n    }\n\n    attributeChangedCallback(name, old_val, new_val) {\n      if (old_val == new_val) {\n        return false;\n      }\n\n      let observed = ['grid', 'use', 'seed'].includes(name);\n\n      if (observed && !is_nil(old_val)) {\n        this[name] = new_val;\n      }\n    }\n\n    get_grid() {\n      return parse_grid(this.attr('grid'));\n    }\n\n    get_use() {\n      let use = this.attr('use') || '';\n      if (use) use = `@use:${use};`;\n      return use;\n    }\n\n    attr(name, value) {\n      if (arguments.length === 1) {\n        return this.getAttribute(name);\n      }\n\n      if (arguments.length === 2) {\n        this.setAttribute(name, value);\n        return value;\n      }\n    }\n\n    generate(parsed) {\n      let grid = this.get_grid();\n      let seed = this.attr('seed') || this.attr('data-seed');\n\n      if (is_nil(seed)) {\n        seed = Date.now();\n      }\n\n      seed = String(seed);\n      this._seed_value = seed;\n      let random = this.random = seedrandom(seed);\n      let compiled = this.compiled = generator(parsed, grid, random);\n      return compiled;\n    }\n\n    doodle_to_image(code, options, fn) {\n      if (typeof options === 'function') {\n        fn = options;\n        options = null;\n      }\n\n      let parsed = parse$1(code, this.extra);\n\n      let _grid = parse_grid({});\n\n      let compiled = generator(parsed, _grid, this.random);\n      let grid = compiled.grid ? compiled.grid : _grid;\n      const {\n        keyframes,\n        host,\n        container,\n        cells\n      } = compiled.styles;\n      let svg_defs = this.build_svg_paths(compiled.paths);\n      let replace = this.replace(compiled);\n      let grid_container = create_grid(grid);\n      let size = options && options.width && options.height ? `width=\"${options.width}\" height=\"${options.height}\"` : '';\n      replace(`\n      <svg ${size} xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\">\n        <foreignObject width=\"100%\" height=\"100%\">\n          <div class=\"host\" xmlns=\"http://www.w3.org/1999/xhtml\">\n            <style>\n              ${get_basic_styles()}\n              ${get_grid_styles(grid)}\n              ${host}\n              ${container}\n              ${cells}\n              ${keyframes}\n            </style>\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0\" height=\"0\">\n              <defs class=\"svg-defs\">${svg_defs}</defs>\n            </svg>\n            ${grid_container}\n          </div>\n        </foreignObject>\n      </svg>\n    `).then(result => {\n        let source = `data:image/svg+xml;base64,${window.btoa(unescape(encodeURIComponent(result)))}`;\n\n        if (is_safari()) {\n          cache_image(source);\n        }\n\n        fn(source);\n      });\n    }\n\n    shader_to_image({\n      shader,\n      cell\n    }, fn) {\n      let parsed = parse$2(shader);\n      let element = this.doodle.getElementById(cell);\n      let {\n        width,\n        height\n      } = element.getBoundingClientRect();\n      let ratio = window.devicePixelRatio || 1;\n\n      if (!parsed.textures.length) {\n        draw_shader(parsed, width, height).then(fn);\n      } // Need to bind textures first\n      else {\n          let transforms = parsed.textures.map(texture => {\n            return new Promise(resolve => {\n              this.doodle_to_image(texture.value, {\n                width,\n                height\n              }, src => {\n                let img = new Image();\n                img.width = width * ratio;\n                img.height = height * ratio;\n\n                img.onload = () => resolve({\n                  name: texture.name,\n                  value: img\n                });\n\n                img.src = src;\n              });\n            });\n          });\n          Promise.all(transforms).then(textures => {\n            parsed.textures = textures;\n            draw_shader(parsed, width, height).then(fn);\n          });\n        }\n    }\n\n    load(again) {\n      if (!again) {\n        if (this.hasAttribute('click-to-update')) {\n          this.addEventListener('click', e => this.update());\n        }\n      }\n\n      let use = this.get_use();\n\n      if (!this.innerHTML.trim() && !use) {\n        return false;\n      }\n\n      let parsed = parse$1(use + un_entity(this.innerHTML), this.extra);\n      let compiled = this.generate(parsed);\n      this.grid_size = compiled.grid ? compiled.grid : this.get_grid();\n      this.build_grid(compiled, this.grid_size);\n    }\n\n    replace({\n      doodles,\n      shaders,\n      paths\n    }) {\n      let doodle_ids = Object.keys(doodles);\n      let shader_ids = Object.keys(shaders);\n      let path_ids = Object.keys(paths);\n      return input => {\n        if (!doodle_ids.length && !shader_ids.length && !path_ids.length) {\n          return Promise.resolve(input);\n        }\n\n        let mappings = [].concat(doodle_ids.map(id => {\n          if (input.includes(id)) {\n            return new Promise(resolve => {\n              this.doodle_to_image(doodles[id], value => resolve({\n                id,\n                value\n              }));\n            });\n          } else {\n            return Promise.resolve('');\n          }\n        }), shader_ids.map(id => {\n          if (input.includes(id)) {\n            return new Promise(resolve => {\n              this.shader_to_image(shaders[id], value => resolve({\n                id,\n                value\n              }));\n            });\n          } else {\n            return Promise.resolve('');\n          }\n        }), path_ids.map(id => {\n          if (input.includes(id)) {\n            return Promise.resolve({\n              id,\n              value: '#' + id\n            });\n          } else {\n            return Promise.resolve('');\n          }\n        }));\n        return Promise.all(mappings).then(mapping => {\n          if (input.replaceAll) {\n            mapping.forEach(({\n              id,\n              value\n            }) => {\n              input = input.replaceAll('${' + id + '}', `url(${value})`);\n            });\n          } else {\n            mapping.forEach(({\n              id,\n              value\n            }) => {\n              input = input.replace('${' + id + '}', `url(${value})`);\n            });\n          }\n\n          return input;\n        });\n      };\n    }\n\n    build_grid(compiled, grid) {\n      const {\n        has_transition,\n        has_animation\n      } = compiled.props;\n      let has_delay = has_transition || has_animation;\n      const {\n        keyframes,\n        host,\n        container,\n        cells\n      } = compiled.styles;\n      let style_container = get_grid_styles(grid) + host + container;\n      let style_cells = has_delay ? '' : cells;\n      let svg_defs = this.build_svg_paths(compiled.paths);\n      const {\n        uniforms\n      } = compiled;\n      let replace = this.replace(compiled);\n      this.doodle.innerHTML = `\n      <style>${get_basic_styles(uniforms)}</style>\n      <style class=\"style-keyframes\">${keyframes}</style>\n      <style class=\"style-container\">${style_container}</style>\n      <style class=\"style-cells\">${style_cells}</style>\n      <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0\" height=\"0\">\n        <defs class=\"svg-defs\">${svg_defs}</defs>\n      </svg>\n      ${create_grid(grid)}\n    `;\n      this.set_content('.style-container', replace(style_container));\n\n      if (has_delay) {\n        setTimeout(() => {\n          this.set_content('.style-cells', replace(cells));\n        }, 50);\n      } else {\n        this.set_content('.style-cells', replace(cells));\n      } // might be removed in the future\n\n\n      const definitions = compiled.definitions;\n\n      if (window.CSS && window.CSS.registerProperty) {\n        try {\n          if (uniforms.time) {\n            this.register_uniform_time();\n          }\n\n          definitions.forEach(CSS.registerProperty);\n        } catch (e) {}\n      }\n    }\n\n    build_svg_paths(paths) {\n      let names = Object.keys(paths || {});\n      return names.map(name => `\n      <clipPath id=\"${paths[name].id}\" clipPathUnits=\"objectBoundingBox\">\n        <path d=\"${paths[name].commands}\" />\n      </clipPath>\n    `).join('');\n    }\n\n    register_uniform_time() {\n      if (!this.is_uniform_time_registered) {\n        try {\n          CSS.registerProperty({\n            name: '--' + uniform_time.name,\n            syntax: '<number>',\n            initialValue: 0,\n            inherits: true\n          });\n        } catch (e) {}\n\n        this.is_uniform_time_registered = true;\n      }\n    }\n\n    export({\n      scale,\n      name,\n      download,\n      detail\n    } = {}) {\n      return new Promise((resolve, reject) => {\n        let variables = get_all_variables(this);\n        let html = this.doodle.innerHTML;\n        let {\n          width,\n          height\n        } = this.getBoundingClientRect();\n        scale = parseInt(scale) || 1;\n        let w = width * scale;\n        let h = height * scale;\n        let svg = minify(`\n        <svg xmlns=\"http://www.w3.org/2000/svg\"\n          preserveAspectRatio=\"none\"\n          viewBox=\"0 0 ${width} ${height}\"\n          ${is_safari() ? '' : `width=\"${w}px\" height=\"${h}px\"`}\n        >\n          <foreignObject width=\"100%\" height=\"100%\">\n            <div\n              class=\"host\"\n              xmlns=\"http://www.w3.org/1999/xhtml\"\n              style=\"width: ${width}px; height: ${height}px; \"\n            >\n              <style>.host { ${variables} }</style>\n              ${html}\n            </div>\n          </foreignObject>\n        </svg>\n      `);\n\n        if (download || detail) {\n          svg_to_png(svg, w, h, scale).then(({\n            source,\n            url,\n            blob\n          }) => {\n            resolve({\n              width: w,\n              height: h,\n              svg,\n              blob,\n              source\n            });\n\n            if (download) {\n              let a = document.createElement('a');\n              a.download = normalize_png_name(name);\n              a.href = url;\n              a.click();\n            }\n          }).catch(error => {\n            reject(error);\n          });\n        } else {\n          resolve({\n            width: w,\n            height: h,\n            svg: svg\n          });\n        }\n      });\n    }\n\n    set_content(selector, styles) {\n      if (styles instanceof Promise) {\n        styles.then(value => {\n          this.set_content(selector, value);\n        });\n      } else {\n        const el = this.shadowRoot.querySelector(selector);\n        el && (el.styleSheet ? el.styleSheet.cssText = styles : el.innerHTML = styles);\n      }\n    }\n\n  }\n\n  if (!customElements.get('css-doodle')) {\n    customElements.define('css-doodle', Doodle);\n  }\n\n  function get_basic_styles(uniforms = {}) {\n    const inherited_grid_props = get_props(/grid/).map(n => `${n}: inherit;`).join('');\n    return `\n    * {\n      box-sizing: border-box\n    }\n    *::after, *::before {\n      box-sizing: inherit\n    }\n    :host, .host {\n      display: block;\n      visibility: visible;\n      width: auto;\n      height: auto;\n      --${uniform_time.name}: 0\n    }\n    :host([hidden]), .host[hidden] {\n      display: none\n    }\n    .container {\n      position: relative;\n      width: 100%;\n      height: 100%;\n      display: grid;\n      ${inherited_grid_props}\n    }\n    cell:empty {\n      position: relative;\n      line-height: 1;\n      display: grid;\n      place-items: center\n    }\n    svg {\n      position: absolute;\n    }\n  `;\n  }\n\n  function get_grid_styles({\n    x,\n    y\n  }) {\n    return `\n    :host, .host {\n      grid-template-rows: repeat(${y}, 1fr);\n      grid-template-columns: repeat(${x}, 1fr);\n    }\n  `;\n  }\n\n  function minify(input) {\n    return input.replace(/\\n\\s+|^\\s+|\\n+/g, ' ').trim();\n  }\n\n  function create_cell(x, y, z) {\n    let cell = document.createElement('cell');\n    cell.id = cell_id(x, y, z);\n    return cell;\n  }\n\n  function create_grid({\n    x,\n    y,\n    z\n  }) {\n    let grid = document.createElement('grid');\n    let root = document.createDocumentFragment();\n\n    if (z == 1) {\n      for (let j = 1; j <= y; ++j) {\n        for (let i = 1; i <= x; ++i) {\n          root.appendChild(create_cell(i, j, 1));\n        }\n      }\n    } else {\n      let temp = null;\n\n      for (let i = 1; i <= z; ++i) {\n        let cell = create_cell(1, 1, i);\n        (temp || root).appendChild(cell);\n        temp = cell;\n      }\n\n      temp = null;\n    }\n\n    grid.className = 'container';\n    grid.appendChild(root);\n    return grid.outerHTML;\n  }\n\n  function CSSDoodle(input, ...vars) {\n    let get_value = v => is_nil(v) ? '' : v;\n\n    let rules = input.reduce((s, c, i) => s + c + get_value(vars[i]), '');\n    let doodle = document.createElement('css-doodle');\n\n    if (doodle.update) {\n      doodle.update(rules);\n    }\n\n    return doodle;\n  }\n\n  return CSSDoodle;\n});","map":{"version":3,"sources":["/Users/macpro/GITHUB/REPOSITORIES PINNED/Calculator/node_modules/css-doodle/css-doodle.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","CSSDoodle","iterator","input","index","col","line","curr","n","end","length","info","undefined","next","parse","it","word","marks","groups","result","c","push","test","name","alternative","pop","Error","parse_var","trim","e","console","warn","message","List","random","make_array","arr","Array","isArray","join","spliter","last","first","clone","JSON","stringify","shuffle","ret","from","slice","m","i","t","flat_map","fn","prototype","flatMap","reduce","acc","x","concat","remove_empty_values","filter","v","String","Tokens","func","type","arguments","argument","value","text","pseudo","selector","styles","cond","rule","property","keyframes","steps","step","is","white_space","line_break","number","isNaN","pair","includes","pair_of","symbols","Math","PI","throw_error","msg","get_text_value","read_until","reset","read_word","check","read_keyframe_name","read_line","read_step","extra","read_selector","read_rule","read_steps","read_keyframes","read_comments","flag","inline","read_tag","read_property","prop","read_arguments","composition","doodle","args","group","stack","arg","trimLeft","read_func","startsWith","raw","substr","cloned","normalize_argument","map","replace","ft","ed","cf","ce","cluster","seperate_func_name","fname","prev","substring","has_argument","unshift","position","read_value","idx","skip","read_cond_selector","read_pseudo","read_var","read_cond","Object","assign","read_variable","get_variable","evaluate_value","values","forEach","vars","p","other","parsed","every","parse$1","apply","token","clamp","num","min","max","maybe","range","start","stop","count","old","initial","alias_for","obj","names","keys","is_letter","is_nil","s","lazy","wrap","sequence","y","split","parseInt","j","cell_id","z","get_value","normalize_png_name","prefix","Date","now","cache_image","src","delay","img","Image","crossOrigin","onload","setTimeout","is_safari","navigator","userAgent","un_entity","code","textarea","document","createElement","innerHTML","total","parse_grid","size","max_xy","max_z","is_quote","last$1","array","parse$2","temp","textures","w","words","key","need_break","fragment","create_svg_url","svg","id","encoded","encodeURIComponent","normalize_svg","xmlns","svg_to_png","width","height","scale","Promise","resolve","reject","source","action","canvas","ctx","getContext","dpr","window","devicePixelRatio","drawImage","toBlob","blob","url","URL","createObjectURL","random_func","lerp","rand","nrand","mean","u1","u2","R","sqrt","log","u0","cos","pick","items","unique_id","toString","by_unit","unit","get_unit","restore","str","Number","some","matched","match","by_charcode","codes","charCodeAt","fromCharCode","last$2","default_context","calc","context","expr","infix_to_postfix","calc$1","operator","repeat","shift","expand","is_cycle","output","fns","right","left","compute","get_tokens","tokens","op_stack","func_body","op","a","b","pow","_","variable","store","memo","last$3","expand$1","build_range","Type","get_tokens$1","endsWith","to","reverse","Node","constructor","data","Stack","limit","_limit","_size","root","node","tail","sin","atan2","DEG","polygon","option","deg","points","add_point","first2","point","frame","theta","read_fillrule","rotate","rad","translate","offset","dx","dy","shapes","circle","triangle","rhombus","pentagon","hexgon","hexagon","heptagon","octagon","star","diamond","cross","clover","k","hypocycloid","astroid","infinity","heart","bean","bicorn","drop","pear","fish","whale","r","bud","alien","d","is_empty","custom_shape","props","degree","px","py","pr","list","origin","is_seperator","no_space","skip_seperator","parse$3","parse$4","read_comments$1","uniform_time","get_exposed","Expose","row","depth","grid","nx","ny","N","make_sequence","multiple","push_stack","counter","pos","last_pick","transform_type","rand_int","round","nrand_int","last_rand","stripe","colors","default_count","custom_sizes","default_size","color","hex","var","shape","commands","rest","config","shaders","path","all","get_props","Set","head","style","add","toLowerCase","has","build_mapping","reg","RegExp","props_webkit_mapping","props_moz_mapping","prefixer","presets","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","b10","b11","b12","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","c10","c11","c12","d0","d1","d2","d3","d4","d5","d6","letter","legal","ledger","tabloid","executive","postcard","poster","modes","portrait","pt","landscape","ls","l","get_preset","mode","h","is_preset","Property","is_special_selector","map_left_right","map_top_bottom","top","cw","ch","options","rules","build_expr","nth","is$1","even","odd","even_or_odd","Selector","at","x1","y1","exprs","ratio","methods","getOwnPropertyNames","MathFunc","expose","image","integer","angle","time","resolution","percentage","get_definition","syntax","initialValue","inherits","is_host_selector","is_parent_selector","Rules","is_grid_defined","coords","doodles","paths","Func","custom_properties","uniforms","host","container","cells","add_rule","pick_func","apply_func","_fn","is_string_or_number","compose_aname","compose_selector","is_composable","compose_argument","compose_doodle","compose_shaders","compose_path","shader","cell","compose_value","val","compose_rule","_coords","value_group","composed","has_animation","has_transition","transformed","compose","pre_compose_rule","pre_compose","special","target","animation","aname","definitions","def","generator","grid_size","math","pool","chunks","digits","rngname","startdenom","significance","overflow","mask","nodecrypto","seedrandom","seed","callback","entropy","shortseed","mixkey","flatten","tostring","autoseed","arc4","ARC4","prng","g","int32","quick","double","S","pass","is_math_call","state","copy","keylen","me","f","typ","stringseed","smear","out","randomBytes","Uint8Array","crypto","msCrypto","getRandomValues","browser","plugins","screen","create_shader","gl","createShader","shaderSource","compileShader","create_program","vss","fss","vs","VERTEX_SHADER","fs","FRAGMENT_SHADER","prog","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","getShaderInfoLog","add_uniform","uniform","fragment_head","default_vertex_shader","load_texture","texture","createTexture","activeTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","draw_shader","program","vertex","positionAttributeLocation","getAttribLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","vertices","bufferData","Float32Array","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","viewport","drawingBufferWidth","drawingBufferHeight","clearColor","clear","COLOR_BUFFER_BIT","useProgram","uniform2fv","getUniformLocation","uniform1i","drawArrays","TRIANGLES","toDataURL","get_all_variables","element","computedStyleMap","getComputedStyle","getPropertyValue","Doodle","HTMLElement","attachShadow","connectedCallback","again","readyState","load","update","use","get_use","get_grid","gx","gy","gz","compiled","generate","shadowRoot","build_grid","svg_paths","build_svg_paths","defs","querySelector","register_uniform_time","set_content","get_grid_styles","attr","_seed_value","observedAttributes","attributeChangedCallback","old_val","new_val","observed","getAttribute","setAttribute","doodle_to_image","_grid","svg_defs","grid_container","create_grid","get_basic_styles","then","btoa","unescape","shader_to_image","getElementById","getBoundingClientRect","transforms","hasAttribute","addEventListener","doodle_ids","shader_ids","path_ids","mappings","mapping","replaceAll","has_delay","style_container","style_cells","CSS","registerProperty","is_uniform_time_registered","export","download","detail","variables","html","minify","href","click","catch","error","el","styleSheet","cssText","customElements","get","inherited_grid_props","create_cell","createDocumentFragment","appendChild","className","outerHTML"],"mappings":"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","sourcesContent":["/*! css-doodle@0.15.3 */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.CSSDoodle = factory());\n}(this, (function () { 'use strict';\n\n  function iterator(input) {\n    let index = 0, col = 1, line = 1;\n    return {\n      curr(n = 0) {\n        return input[index + n];\n      },\n      end() {\n        return input.length <= index;\n      },\n      info() {\n        return { index, col, line };\n      },\n      index(n) {\n        return (n === undefined ? index : index = n);\n      },\n      next() {\n        let next = input[index++];\n        if (next == '\\n') line++, col = 0;\n        else col++;\n        return next;\n      }\n    };\n  }\n\n  // I'll make it work first\n  function parse(it) {\n    let word = '', marks = [];\n    let groups = [], result = {};\n\n    while(!it.end()) {\n      let c = it.curr();\n      if (c == '(') {\n        marks.push(c);\n        word = '';\n      }\n      else if (c == ')' || c == ',') {\n        if (/^\\-\\-.+/.test(word)) {\n          if (!result.name) {\n            result.name = word;\n          } else {\n            if (!result.alternative) {\n              result.alternative = [];\n            }\n            result.alternative.push({\n              name: word\n            });\n          }\n        }\n\n        if (c == ')') {\n          if (marks[marks.length - 1] == '(') {\n            marks.pop();\n          } else {\n            throw new Error('bad match');\n          }\n        }\n\n        if (c == ',') {\n          if (!marks.length) {\n            groups.push(result);\n            result = {};\n          }\n        }\n\n        word = '';\n      }\n      else if (!/\\s/.test(c)) {\n        word += c;\n      }\n      it.next();\n    }\n\n    if (marks.length) {\n      return [];\n    }\n\n    if (result.name) {\n      groups.push(result);\n    }\n    return groups;\n  }\n\n  function parse_var(input) {\n    input = input.trim();\n    let result = [];\n    if (!/^var\\(/.test(input)) {\n      return result;\n    }\n    let it = iterator(input);\n    try {\n      result = parse(it);\n    } catch (e) {\n      console.warn(e && e.message || 'Bad variables.');\n    }\n    return result;\n  }\n\n  function List(random) {\n\n    function make_array(arr) {\n      return Array.isArray(arr) ? arr : [arr];\n    }\n\n    function join(arr, spliter = '\\n') {\n      return (arr || []).join(spliter);\n    }\n\n    function last(arr, n = 1) {\n      return arr[arr.length - n];\n    }\n\n    function first(arr) {\n      return arr[0];\n    }\n\n    function clone(arr) {\n      return JSON.parse(JSON.stringify(arr));\n    }\n\n    function shuffle(arr) {\n      let ret = Array.from ? Array.from(arr) : arr.slice();\n      let m = arr.length;\n      while (m) {\n        let i = ~~(random() * m--);\n        let t = ret[m];\n        ret[m] = ret[i];\n        ret[i] = t;\n      }\n      return ret;\n    }\n\n    function flat_map(arr, fn) {\n      if (Array.prototype.flatMap) return arr.flatMap(fn);\n      return arr.reduce((acc, x) => acc.concat(fn(x)), []);\n    }\n\n    function remove_empty_values(arr) {\n      return arr.filter(v => (\n        v !== undefined &&\n        v !== null &&\n        String(v).trim().length\n      ));\n    }\n\n    return {\n      make_array,\n      join,\n      last,\n      first,\n      clone,\n      shuffle,\n      flat_map,\n      remove_empty_values\n    }\n  }\n\n  let { first, last, clone } = List();\n\n  const Tokens = {\n    func(name = '') {\n      return {\n        type: 'func',\n        name,\n        arguments: []\n      };\n    },\n    argument() {\n      return {\n        type: 'argument',\n        value: []\n      };\n    },\n    text(value = '') {\n      return {\n        type: 'text',\n        value\n      };\n    },\n    pseudo(selector = '') {\n      return {\n        type: 'pseudo',\n        selector,\n        styles: []\n      };\n    },\n    cond(name = '') {\n      return {\n        type: 'cond',\n        name,\n        styles: [],\n        arguments: []\n      };\n    },\n    rule(property = '') {\n      return {\n        type: 'rule',\n        property,\n        value: []\n      };\n    },\n    keyframes(name = '') {\n      return {\n        type: 'keyframes',\n        name,\n        steps: []\n      }\n    },\n\n    step(name = '') {\n      return {\n        type: 'step',\n        name,\n        styles: []\n      }\n    }\n  };\n\n  const is = {\n    white_space(c) {\n      return /[\\s\\n\\t]/.test(c);\n    },\n    line_break(c) {\n      return /\\n/.test(c);\n    },\n    number(n) {\n      return !isNaN(n);\n    },\n    pair(n) {\n      return ['\"', '(', ')', \"'\"].includes(n);\n    },\n    pair_of(c, n) {\n      return ({ '\"': '\"', \"'\": \"'\", '(': ')' })[c] == n;\n    }\n  };\n\n  // This should not be in the parser\n  // but I'll leave it here until the rewriting\n  const symbols = {\n    'π': Math.PI,\n    '∏': Math.PI\n  };\n\n  function throw_error(msg, { col, line }) {\n    console.warn(\n      `(at line ${ line }, column ${ col }) ${ msg }`\n    );\n  }\n\n  function get_text_value(input) {\n    if (input.trim().length) {\n      return is.number(+input) ? +input : input.trim()\n    } else {\n      return input;\n    }\n  }\n\n  function read_until(fn) {\n    return function(it, reset) {\n      let index = it.index();\n      let word = '';\n      while (!it.end()) {\n        let c = it.next();\n        if (fn(c)) break;\n        else word += c;\n      }\n      if (reset) {\n        it.index(index);\n      }\n      return word;\n    }\n  }\n\n  function read_word(it, reset) {\n    let check = c => /[^\\w@]/.test(c);\n    return read_until(check)(it, reset);\n  }\n\n  function read_keyframe_name(it) {\n    return read_until(c => /[\\s\\{]/.test(c))(it);\n  }\n\n  function read_line(it, reset) {\n    let check = c => is.line_break(c) || c == '{';\n    return read_until(check)(it, reset);\n  }\n\n  function read_step(it, extra) {\n    let c, step = Tokens.step();\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else if (!step.name.length) {\n        step.name = read_selector(it);\n      }\n      else {\n        step.styles.push(read_rule(it, extra));\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return step;\n  }\n\n  function read_steps(it, extra) {\n    const steps = [];\n    let c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      else if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else {\n        steps.push(read_step(it, extra));\n      }\n      it.next();\n    }\n    return steps;\n  }\n\n  function read_keyframes(it, extra) {\n    let keyframes = Tokens.keyframes(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      else if (!keyframes.name.length) {\n        read_word(it);\n        keyframes.name = read_keyframe_name(it);\n        if (!keyframes.name.length) {\n          throw_error('missing keyframes name', it.info());\n          break;\n        }\n        continue;\n      }\n      else if (c == '{') {\n        it.next();\n        keyframes.steps = read_steps(it, extra);\n        break;\n      }\n      it.next();\n    }\n    return keyframes;\n  }\n\n  function read_comments(it, flag = {}) {\n    it.next();\n    while (!it.end()) {\n      let c = it.curr();\n      if (flag.inline) {\n        if (c == '\\n') break;\n      }\n      else {\n        if ((c = it.curr()) == '*' && it.curr(1) == '/') break;\n      }\n      it.next();\n    }\n    if (!flag.inline) {\n      it.next(); it.next();\n    }\n  }\n\n  function read_tag(it) {\n    it.next();\n    while(!it.end()) {\n      let c = it.curr();\n      if (c == '>') break;\n      it.next();\n    }\n  }\n\n  function read_property(it) {\n    let prop = '', c;\n    while (!it.end()) {\n      if ((c = it.curr()) == ':') break;\n      else if (!is.white_space(c)) prop += c;\n      it.next();\n    }\n    return prop;\n  }\n\n  function read_arguments(it, composition, doodle) {\n    let args = [], group = [], stack = [], arg = '', c;\n    while (!it.end()) {\n      c = it.curr();\n      if ((/[\\('\"`]/.test(c) && it.curr(-1) !== '\\\\')) {\n        if (stack.length) {\n          if (c != '(' && c === last(stack)) {\n            stack.pop();\n          } else {\n            stack.push(c);\n          }\n        } else {\n          stack.push(c);\n        }\n        arg += c;\n      }\n      else if (c == '@' && !doodle) {\n        if (!group.length) {\n          arg = arg.trimLeft();\n        }\n        if (arg.length) {\n          group.push(Tokens.text(arg));\n          arg = '';\n        }\n        group.push(read_func(it));\n      }\n      else if (doodle && /[)]/.test(c) || (!doodle && /[,)]/.test(c))) {\n        if (stack.length) {\n          if (c == ')') {\n            stack.pop();\n          }\n          arg += c;\n        }\n\n        else {\n          if (arg.length) {\n            if (!group.length) {\n              group.push(Tokens.text(get_text_value(arg)));\n            } else {\n              group.push(Tokens.text(arg));\n            }\n\n            if (arg.startsWith('±') && !doodle) {\n              let raw = arg.substr(1);\n              let cloned = clone(group);\n              last(cloned).value = '-' + raw;\n              args.push(normalize_argument(cloned));\n              last(group).value = raw;\n            }\n          }\n\n          args.push(normalize_argument(group));\n\n          [group, arg] = [[], ''];\n\n          if (c == ')') break;\n        }\n      }\n      else {\n        if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n          c = symbols[c];\n        }\n        arg += c;\n      }\n\n      if (composition && it.curr() == ')' && !stack.length) {\n        if (group.length) {\n          args.push(normalize_argument(group));\n        }\n        break;\n      }\n      else {\n        it.next();\n      }\n    }\n    return args;\n  }\n\n  function normalize_argument(group) {\n    let result = group.map(arg => {\n      if (arg.type == 'text' && typeof arg.value == 'string') {\n        let value = String(arg.value);\n        if (value.includes('`')) {\n          arg.value = value = value.replace(/`/g, '\"');\n        }\n        arg.value = value.replace(/\\n+|\\s+/g, ' ');\n      }\n      return arg;\n    });\n\n    let ft = first(result) || {};\n    let ed = last(result) || {};\n    if (ft.type == 'text' && ed.type == 'text') {\n      let cf = first(ft.value);\n      let ce  = last(ed.value);\n      if (typeof ft.value == 'string' && typeof ed.value == 'string') {\n        if (is.pair_of(cf, ce)) {\n          ft.value = ft.value.slice(1);\n          ed.value = ed.value.slice(0, ed.value.length - 1);\n          result.cluster = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function seperate_func_name(name) {\n    let fname = '', extra = '';\n    if ((/\\D$/.test(name) && !/\\d+x\\d+/.test(name)) || Math[name.substr(1)]) {\n      return { fname: name, extra }\n    }\n    for (let i = name.length - 1; i >= 0; i--) {\n      let c = name[i];\n      let prev = name[i - 1];\n      let next = name[i + 1];\n      if (/[\\d.]/.test(c) || ((c == 'x') && /\\d/.test(prev) && /\\d/.test(next))) {\n        extra = c + extra;\n      } else {\n        fname = name.substring(0, i + 1);\n        break;\n      }\n    }\n    return { fname, extra };\n  }\n\n  function read_func(it) {\n    let func = Tokens.func();\n    let name = '@', c;\n    let has_argument = false;\n    it.next();\n\n    while (!it.end()) {\n      c = it.curr();\n      let composition = (c == '.' && it.curr(1) == '@');\n      let next = it.curr(1);\n      if (c == '(' || composition) {\n        has_argument = true;\n        it.next();\n        func.arguments = read_arguments(it, composition, name === '@doodle' || name == '@shaders');\n        break;\n      } else if (!has_argument && next !== '(' && !/[0-9a-zA-Z_\\-.]/.test(next)) {\n        name += c;\n        break;\n      }\n      else {\n        name += c;\n      }\n      it.next();\n    }\n\n    let { fname, extra } = seperate_func_name(name);\n    func.name = fname;\n\n    if (extra.length) {\n      func.arguments.unshift([{\n        type: 'text',\n        value: extra\n      }]);\n    }\n\n    func.position = it.info().index;\n    return func;\n  }\n\n  function read_value(it) {\n    let text = Tokens.text(), idx = 0, skip = true, c;\n    const value = [], stack = [];\n    value[idx] = [];\n\n    while (!it.end()) {\n      c = it.curr();\n\n      if (skip && is.white_space(c)) {\n        it.next();\n        continue;\n      } else {\n        skip = false;\n      }\n\n      if (c == '\\n' && !is.white_space(it.curr(-1))) {\n        text.value += ' ';\n      }\n      else if (c == ',' && !stack.length) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        value[++idx] = [];\n        skip = true;\n      }\n      else if (/[;}]/.test(c)) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        break;\n      }\n      else if (c == '@') {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        value[idx].push(read_func(it));\n      }\n      else if (!is.white_space(c) || !is.white_space(it.curr(-1))) {\n        if (c == '(') stack.push(c);\n        if (c == ')') stack.pop();\n\n        if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n          c = symbols[c];\n        }\n\n        text.value += c;\n      }\n      it.next();\n    }\n    if (text.value.length) {\n      value[idx].push(text);\n    }\n    return value;\n  }\n\n  function read_selector(it) {\n    let selector = '', c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '{') break;\n      else if (!is.white_space(c)) {\n        selector += c;\n      }\n      it.next();\n    }\n    return selector;\n  }\n\n  function read_cond_selector(it) {\n    let selector = { name: '', arguments: [] }, c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '(') {\n        it.next();\n        selector.arguments = read_arguments(it);\n      }\n      else if (/[){]/.test(c)) break;\n      else if (!is.white_space(c)) selector.name += c;\n      it.next();\n    }\n    return selector;\n  }\n\n  function read_pseudo(it, extra) {\n    let pseudo = Tokens.pseudo(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else if (!pseudo.selector) {\n        pseudo.selector = read_selector(it);\n      }\n      else {\n        let rule = read_rule(it, extra);\n        if (rule.property == '@use') {\n          pseudo.styles = pseudo.styles.concat(\n            rule.value\n          );\n        } else {\n          pseudo.styles.push(rule);\n        }\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return pseudo;\n  }\n\n  function read_rule(it, extra) {\n    let rule = Tokens.rule(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == ';') break;\n      else if (!rule.property.length) {\n        rule.property = read_property(it);\n        if (rule.property == '@use') {\n          rule.value = read_var(it, extra);\n          break;\n        }\n      }\n      else {\n        rule.value = read_value(it);\n        break;\n      }\n      it.next();\n    }\n    return rule;\n  }\n\n  function read_cond(it, extra) {\n    let cond = Tokens.cond(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      else if (!cond.name.length) {\n        Object.assign(cond, read_cond_selector(it));\n      }\n      else if (c == ':') {\n        let pseudo = read_pseudo(it);\n        if (pseudo.selector) cond.styles.push(pseudo);\n      }\n      else if (c == '@' && !read_line(it, true).includes(':')) {\n        cond.styles.push(read_cond(it));\n      }\n      else if (!is.white_space(c)) {\n        let rule = read_rule(it, extra);\n        if (rule.property) cond.styles.push(rule);\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return cond;\n  }\n\n  function read_variable(extra, name) {\n    let rule = '';\n    if (extra && extra.get_variable) {\n      rule = extra.get_variable(name);\n    }\n    return rule;\n  }\n\n  function evaluate_value(values, extra) {\n    values.forEach && values.forEach(v => {\n      if (v.type == 'text' && v.value) {\n        let vars = parse_var(v.value);\n        v.value = vars.reduce((ret, p) => {\n          let rule = '', other = '', parsed;\n          rule = read_variable(extra, p.name);\n          if (!rule && p.alternative) {\n            p.alternative.every(n => {\n              other = read_variable(extra, n.name);\n              if (other) {\n                rule = other;\n                return false;\n              }\n            });\n          }\n          try {\n            parsed = parse$1(rule, extra);\n          } catch (e) { }\n          if (parsed) {\n            ret.push.apply(ret, parsed);\n          }\n          return ret;\n        }, []);\n      }\n      if (v.type == 'func' && v.arguments) {\n        v.arguments.forEach(arg => {\n          evaluate_value(arg, extra);\n        });\n      }\n    });\n  }\n\n  function read_var(it, extra) {\n    it.next();\n    let groups = read_value(it) || [];\n    return groups.reduce((ret, group) => {\n      evaluate_value(group, extra);\n      let [token] = group;\n      if (token.value && token.value.length) {\n        ret.push(...token.value);\n      }\n      return ret;\n    }, []);\n  }\n\n  function parse$1(input, extra) {\n    const it = iterator(input);\n    const Tokens = [];\n    while (!it.end()) {\n      let c = it.curr();\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else if (c == '/' && it.curr(1) == '*') {\n        read_comments(it);\n      }\n      else if (c == '/' && it.curr(1) == '/') {\n        read_comments(it, { inline: true });\n      }\n      else if (c == ':') {\n        let pseudo = read_pseudo(it, extra);\n        if (pseudo.selector) Tokens.push(pseudo);\n      }\n      else if (c == '@' && read_word(it, true) === '@keyframes') {\n        let keyframes = read_keyframes(it, extra);\n        Tokens.push(keyframes);\n      }\n      else if (c == '@' && !read_line(it, true).includes(':')) {\n        let cond = read_cond(it, extra);\n        if (cond.name.length) Tokens.push(cond);\n      }\n      else if (c == '<') {\n        read_tag(it);\n      }\n      else if (!is.white_space(c)) {\n        let rule = read_rule(it, extra);\n        if (rule.property) Tokens.push(rule);\n      }\n      it.next();\n    }\n    return Tokens;\n  }\n\n  function clamp(num, min, max) {\n    return Math.max(min, Math.min(max, num));\n  }\n\n  function maybe(cond, value) {\n    if (!cond) return '';\n    return (typeof value === 'function') ? value() : value;\n  }\n\n  function range(start, stop, step) {\n    let count = 0, old = start;\n    let initial = n => (n > 0 && n < 1) ? .1 : 1;\n    let length = arguments.length;\n    if (length == 1) [start, stop] = [initial(start), start];\n    if (length < 3) step = initial(start);\n    let range = [];\n    while ((step >= 0 && start <= stop)\n      || (step < 0 && start > stop)) {\n      range.push(start);\n      start += step;\n      if (count++ >= 1000) break;\n    }\n    if (!range.length) range.push(old);\n    return range;\n  }\n\n  function alias_for(obj, names) {\n    Object.keys(names).forEach(n => {\n      obj[n] = obj[names[n]];\n    });\n    return obj;\n  }\n\n  function is_letter(c) {\n    return /^[a-zA-Z]$/.test(c);\n  }\n\n  function is_nil(s) {\n    return s === undefined || s === null;\n  }\n\n  function lazy(fn) {\n    let wrap = () => fn;\n    wrap.lazy = true;\n    return wrap;\n  }\n\n  function sequence(count, fn) {\n    let [x, y = 1] = String(count).split('x');\n    x = clamp(parseInt(x) || 1, 1, 65536);\n    y = clamp(parseInt(y) || 1, 1, 65536);\n    let max = x * y;\n    let ret = [];\n    let index = 1;\n    for (let i = 1; i <= y; ++i) {\n      for (let j = 1; j <= x; ++j) {\n        ret.push(fn(index++, j, i, max));\n      }\n    }\n    return ret;\n  }\n\n  function cell_id(x, y, z) {\n    return 'c-' + x + '-' + y + '-' + z;\n  }\n\n  function get_value(input) {\n    while (input && input.value) {\n      return get_value(input.value);\n    }\n    return is_nil(input) ? '' : input;\n  }\n\n  function normalize_png_name(name) {\n    let prefix = is_nil(name)\n      ? Date.now()\n      : String(name).replace(/\\/.png$/g, '');\n    return prefix + '.png';\n  }\n\n  function cache_image(src, fn, delay = 0) {\n    let img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.src = src;\n    img.onload = function() {\n      setTimeout(fn, delay);\n    };\n  }\n\n  function is_safari() {\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  }\n\n  function un_entity(code) {\n    let textarea = document.createElement('textarea');\n    textarea.innerHTML = code;\n    return textarea.value;\n  }\n\n  const [ min, max, total ] = [ 1, 32, 32 * 32 ];\n\n  function parse_grid(size) {\n    let [x, y, z] = (size + '')\n      .replace(/\\s+/g, '')\n      .replace(/[,，xX]+/g, 'x')\n      .split('x')\n      .map(n => parseInt(n));\n\n    const max_xy = (x == 1 || y == 1) ? total : max;\n    const max_z = (x == 1 && y == 1) ? total : min;\n\n    const ret = {\n      x: clamp(x || min, 1, max_xy),\n      y: clamp(y || x || min, 1, max_xy),\n      z: clamp(z || min, 1, max_z)\n    };\n\n    return Object.assign({}, ret,\n      { count: ret.x * ret.y * ret.z }\n    );\n  }\n\n  function is_quote(c) {\n    return c == '\"' || c == \"'\";\n  }\n\n  function last$1(array) {\n    return array[array.length - 1];\n  }\n\n  function parse$2(input) {\n    let c = '';\n    let temp = '';\n    let name = '';\n    let stack = [];\n    let result = {\n      textures: []\n    };\n    let w = '';\n    let words = [];\n    let i = 0;\n    while ((c = input[i++]) !== undefined) {\n      if (c == '\"' || c == \"'\") {\n        if (last$1(stack) == c) {\n          stack.pop();\n        } else {\n          stack.push(c);\n        }\n      }\n      if (c == '{' && !is_quote(last$1(stack)))  {\n        if (!stack.length) {\n          name = temp;\n          temp = '';\n        } else {\n          temp += c;\n        }\n        stack.push(c);\n      }\n      else if (c == '}' && !is_quote(last$1(stack)))  {\n        stack.pop();\n        if (!stack.length) {\n          let key = name.trim();\n          let value = temp.trim().replace(/^\\(+|\\)+$/g, '');\n          if (key.length) {\n            if (key.startsWith('texture')) {\n              result.textures.push({\n                name: key,\n                value: value\n              });\n            } else {\n              result[key] = value;\n            }\n          }\n          name = temp = '';\n        } else {\n          temp += c;\n        }\n      }\n      else {\n        if (/\\s/.test(c) && w.length) {\n          words.push(w);\n          w = '';\n          let need_break =\n            (words[words.length - 3] == '#define') ||\n            (words[words.length - 2] == '#ifdef') ||\n            (words[words.length - 1] == '#else') ||\n            (words[words.length - 1] == '#endif');\n\n          if (need_break) {\n            temp = temp + '\\n';\n          }\n        } else {\n          w += c;\n        }\n        temp += c;\n      }\n    }\n\n    if (result.fragment === undefined) {\n      return {\n        fragment: input,\n        textures: []\n      }\n    }\n\n    return result;\n  }\n\n  function create_svg_url(svg, id) {\n    let encoded = encodeURIComponent(svg) + (id ? `#${ id }` : '');\n    return `url(\"data:image/svg+xml;utf8,${ encoded }\")`;\n  }\n\n  function normalize_svg(input) {\n    const xmlns = 'xmlns=\"http://www.w3.org/2000/svg\"';\n    if (!input.includes('<svg')) {\n      input = `<svg ${ xmlns }>${ input }</svg>`;\n    }\n    if (!input.includes('xmlns')) {\n      input = input.replace(/<svg([\\s>])/, `<svg ${ xmlns }$1`);\n    }\n    return input;\n  }\n\n\n  function svg_to_png(svg, width, height, scale) {\n    return new Promise((resolve, reject) => {\n      let source = `data:image/svg+xml;utf8,${ encodeURIComponent(svg) }`;\n\n      function action() {\n        let img = new Image();\n        img.crossOrigin = 'anonymous';\n        img.src = source;\n\n        img.onload = () => {\n          let canvas = document.createElement('canvas');\n          let ctx = canvas.getContext('2d');\n\n          let dpr = window.devicePixelRatio || 1;\n          /* scale with devicePixelRatio only when the scale equals 1 */\n          if (scale != 1) {\n            dpr = 1;\n          }\n\n          canvas.width = width * dpr;\n          canvas.height = height * dpr;\n          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n          try {\n            canvas.toBlob(blob => {\n              resolve({\n                blob,\n                source,\n                url: URL.createObjectURL(blob)\n              });\n            });\n          } catch (e) {\n            reject(e);\n          }\n        };\n      }\n\n      if (is_safari) {\n        cache_image(source, action, 200);\n      } else {\n        action();\n      }\n    });\n  }\n\n  function random_func(random) {\n\n    function lerp(start, end, t) {\n      return start * (1 - t) + end * t;\n    }\n\n    function rand(start = 0, end = start) {\n      if (arguments.length == 1) {\n        if (start == 1) start = 0;\n        else if (start < 1) start /= 10;\n        else start = 1;\n      }\n      return lerp(start, end, random());\n    }\n\n    function nrand(mean = 0, scale = 1) {\n      let u1 = 0, u2 = 0;\n      //Convert [0,1) to (0,1)\n      while (u1 === 0) u1 = random();\n      while (u2 === 0) u2 = random();\n      const R = Math.sqrt(-2.0 * Math.log(u1));\n      const t = 2.0 * Math.PI * u2;\n      const u0 = R * Math.cos(t);\n      return mean + scale * u0;\n    }\n\n    function pick( ...items) {\n      let args = items.reduce((acc, n) => acc.concat(n), []);\n      return args[~~(random() * args.length)];\n    }\n\n    function unique_id(prefix = '') {\n      return prefix + Math.random().toString(32).substr(2);\n    }\n\n    return {\n      lerp,\n      rand,\n      nrand,\n      pick,\n      unique_id\n    };\n\n  }\n\n  function by_unit(fn) {\n    return (...args) => {\n      let unit = get_unit(args);\n      return restore(fn, unit).apply(null, args);\n    }\n  }\n\n  function restore(fn, unit) {\n    return (...args) => {\n      args = args.map(str => Number(\n        String(str).replace(/\\D+$/g, '')\n      ));\n      let result = fn.apply(null, args);\n      if (!unit.length) {\n        return result;\n      }\n      if (Array.isArray(result)) {\n        return result.map(n => n + unit);\n      }\n      return result + unit;\n    }\n  }\n\n  function get_unit(values) {\n    let unit = '';\n    values.some(str => {\n      let input = String(str).trim();\n      if (!input) return '';\n      let matched = input.match(/\\d(\\D+)$/);\n      return (unit = matched ? matched[1] : '');\n    });\n    return unit;\n  }\n\n  function by_charcode(fn) {\n    return (...args) => {\n      let codes = args.map(n => String(n).charCodeAt(0));\n      let result = fn.apply(null, codes);\n      return Array.isArray(result)\n        ? result.map(n => String.fromCharCode(n))\n        : String.fromCharCode(result);\n    }\n  }\n\n  /**\n   * Based on the Shunting-yard algorithm.\n   */\n  let { last: last$2 } = List();\n\n  const default_context = {\n    'π': Math.PI,\n    '∏': Math.PI\n  };\n\n  function calc(input, context) {\n    const expr = infix_to_postfix(input);\n    return calc$1(expr, Object.assign(default_context, context));\n  }\n\n  const operator = {\n    '^' : 4,\n    '*': 3, '/': 3, '%': 3,\n    '+': 2, '-': 2,\n    '(': 1, ')': 1\n  };\n\n  function calc$1(expr, context, repeat = []) {\n    let stack = [];\n    while (expr.length) {\n      let { name, value, type } = expr.shift();\n      if (type === 'variable') {\n        let result = context[value];\n        if (typeof result === 'undefined') {\n          result = Math[value];\n        }\n        if (typeof result === 'undefined') {\n          result = expand(value, context);\n        }\n        if (typeof result === 'undefined') {\n          result = 0;\n        }\n        if (typeof result !== 'number') {\n          repeat.push(result);\n          if (is_cycle(repeat)) {\n            result = 0;\n            repeat = [];\n          } else {\n            result = calc$1(infix_to_postfix(result), context, repeat);\n          }\n        }\n        stack.push(result);\n      }\n      else if (type === 'function') {\n        let output = value.map(v => calc$1(v, context));\n        let fns = name.split('.');\n        let fname;\n        while (fname = fns.pop()) {\n          if (!fname) continue;\n          let fn = context[fname] || Math[fname];\n          output = (typeof fn === 'function')\n            ? (Array.isArray(output) ? fn(...output) : fn(output))\n            : 0;\n        }\n        stack.push(output);\n      } else {\n        if (/\\d+/.test(value)) stack.push(value);\n        else {\n          let right = stack.pop();\n          let left = stack.pop();\n          stack.push(compute(\n            value, Number(left), Number(right)\n          ));\n        }\n      }\n    }\n    return stack[0];\n  }\n\n  function get_tokens(input) {\n    let expr = String(input);\n    let tokens = [], num = '';\n\n    for (let i = 0; i < expr.length; ++i) {\n      let c = expr[i];\n      if (operator[c]) {\n        if (c == '-' && expr[i - 1] == 'e') {\n          num += c;\n        }\n        else if (!tokens.length && !num.length && /[+-]/.test(c)) {\n          num += c;\n        } else {\n          let { type, value } = last$2(tokens) || {};\n          if (type == 'operator'\n              && !num.length\n              && /[^()]/.test(c)\n              && /[^()]/.test(value)) {\n            num += c;\n          } else {\n            if (num.length) {\n              tokens.push({ type: 'number', value: num });\n              num = '';\n            }\n            tokens.push({ type: 'operator', value: c });\n          }\n        }\n      }\n      else if (/\\S/.test(c)) {\n        if (c == ',') {\n          tokens.push({ type: 'number', value: num });\n          num = '';\n          tokens.push({ type: 'comma', value: c });\n        } else {\n          num += c;\n        }\n      }\n    }\n\n    if (num.length) {\n      tokens.push({ type: 'number', value: num });\n    }\n    return tokens;\n  }\n\n  function infix_to_postfix(input) {\n    let tokens = get_tokens(input);\n    const op_stack = [], expr = [];\n\n    for (let i = 0; i < tokens.length; ++i) {\n      let { type, value } = tokens[i];\n      let next = tokens[i + 1] || {};\n      if (type == 'number') {\n        if (next.value == '(' && /[^\\d.]/.test(value)) {\n          let func_body = '';\n          let stack = [];\n          let values = [];\n\n          i += 1;\n          while (tokens[i++] !== undefined) {\n            let token = tokens[i];\n            if (token === undefined) break;\n            let c = token.value;\n            if (c == ')') {\n              if (!stack.length) break;\n              stack.pop();\n              func_body += c;\n            }\n            else {\n              if (c == '(') stack.push(c);\n              if (c == ',' && !stack.length) {\n                let arg = infix_to_postfix(func_body);\n                if (arg.length) values.push(arg);\n                func_body = '';\n              } else {\n                func_body += c;\n              }\n            }\n          }\n\n          if (func_body.length) {\n            values.push(infix_to_postfix(func_body));\n          }\n\n          expr.push({\n            type: 'function',\n            name: value,\n            value: values\n          });\n        }\n        else if (/[^\\d.]/.test(value)) {\n          expr.push({ type: 'variable', value });\n        }\n        else {\n          expr.push({ type: 'number', value });\n        }\n      }\n\n      else if (type == 'operator') {\n        if (value == '(') {\n          op_stack.push(value);\n        }\n\n        else if (value == ')') {\n          while (op_stack.length && last$2(op_stack) != '(') {\n            expr.push({ type: 'operator', value: op_stack.pop() });\n          }\n          op_stack.pop();\n        }\n\n        else {\n          while (op_stack.length && operator[last$2(op_stack)] >= operator[value]) {\n            let op = op_stack.pop();\n            if (!/[()]/.test(op)) expr.push({ type: 'operator', value: op });\n          }\n          op_stack.push(value);\n        }\n      }\n    }\n\n    while (op_stack.length) {\n      expr.push({ type: 'operator', value: op_stack.pop() });\n    }\n\n    return expr;\n  }\n\n  function compute(op, a, b) {\n    switch (op) {\n      case '+': return a + b;\n      case '-': return a - b;\n      case '*': return a * b;\n      case '/': return a / b;\n      case '%': return a % b;\n      case '^': return Math.pow(a, b);\n    }\n  }\n\n  function expand(value, context) {\n    let [_, num, variable] = value.match(/([\\d.]+)(.*)/) || [];\n    let v = context[variable];\n    if (v === undefined) {\n      return v;\n    }\n    if (typeof v === 'number') {\n      return Number(num) * v;\n    } else {\n      return num * calc$1(infix_to_postfix(v), context);\n    }\n  }\n\n  function is_cycle(array) {\n    return (array[0] == array[2] && array[1] == array[3]);\n  }\n\n  const store = {};\n\n  function memo(prefix, fn) {\n    return (...args) => {\n      let key = prefix + args.join('-');\n      if (store[key]) return store[key];\n      return (store[key] = fn.apply(null, args));\n    }\n  }\n\n  const { last: last$3, flat_map } = List();\n\n  function expand$1(fn) {\n    return (...args) => fn.apply(null, flat_map(args, n =>\n      String(n).startsWith('[') ? build_range(n) : n\n    ));\n  }\n\n  function Type(type, value) {\n    return { type, value };\n  }\n\n  function get_tokens$1(input) {\n    let expr = String(input);\n    let tokens = [], stack = [];\n    if (!expr.startsWith('[') || !expr.endsWith(']')) {\n      return tokens;\n    }\n\n    for (let i = 1; i < expr.length - 1; ++i) {\n      let c = expr[i];\n      if (c == '-' && expr[i - 1] == '-') {\n        continue;\n      }\n      if (c == '-') {\n        stack.push(c);\n        continue;\n      }\n      if (last$3(stack) == '-') {\n        stack.pop();\n        let from = stack.pop();\n        tokens.push(from\n          ? Type('range', [ from, c ])\n          : Type('char', c)\n        );\n        continue;\n      }\n      if (stack.length) {\n        tokens.push(Type('char', stack.pop()));\n      }\n      stack.push(c);\n    }\n    if (stack.length) {\n      tokens.push(Type('char', stack.pop()));\n    }\n    return tokens;\n  }\n\n  const build_range = memo('build_range', (input) => {\n    let tokens = get_tokens$1(input);\n    return flat_map(tokens, ({ type, value }) => {\n      if (type == 'char') return value;\n      let [ from, to ] = value;\n      let reverse = false;\n      if (from > to) {\n        [from, to] = [ to, from ];\n        reverse = true;\n      }\n      let result = by_charcode(range)(from, to);\n      if (reverse) result.reverse();\n      return result;\n    });\n  });\n\n  class Node {\n    constructor(data) {\n      this.prev = this.next = null;\n      this.data = data;\n    }\n  }\n\n  class Stack {\n    constructor(limit = 20) {\n      this._limit = limit;\n      this._size = 0;\n    }\n\n    push(data) {\n      if (this._size >= this._limit) {\n        this.root = this.root.next;\n        this.root.prev = null;\n      }\n\n      let node = new Node(data);\n\n      if (!this.root) {\n        this.root = this.tail = node;\n      } else {\n        node.prev = this.tail;\n        this.tail.next = node;\n        this.tail = node;\n      }\n\n      this._size++;\n    }\n\n    last(n = 1) {\n      let node = this.tail;\n      while (--n) {\n        if (!node.prev) break;\n        node = node.prev;\n      }\n      return node.data;\n    }\n  }\n\n  const { cos, sin, sqrt, atan2, pow, PI } = Math;\n  const DEG = PI / 180;\n\n  function polygon(option, fn) {\n    if (typeof arguments[0] == 'function') {\n      fn = option;\n      option = {};\n    }\n\n    if (!fn) {\n      fn = t => [ cos(t), sin(t) ];\n    }\n\n    let split = option.split || 120;\n    let scale = option.scale || 1;\n    let start = DEG * (option.start || 0);\n    let deg = option.deg ? (option.deg * DEG) : (PI / (split / 2));\n\n    let points = [];\n    let add_point = ([x, y], scale) => {\n      points.push(\n        ((x * 50 * scale) + 50 + '% ') +\n        ((y * 50 * scale) + 50 + '%')\n      );\n    };\n\n    let first, first2;\n\n    for (let i = 0; i < split; ++i) {\n      let t = start - deg * i;\n      let point = fn(t, i);\n      if (!i) first = point;\n      add_point(point, scale);\n    }\n\n    if (option.frame !== undefined) {\n      add_point(first, scale);\n      let w = (option.frame || 1) / 100;\n      if (w <= 0) w = 2 / 1000;\n      for (let i = 0; i < split; ++i) {\n        let t = start + deg * i;\n        let [x, y] = fn(t, i);\n        let theta = atan2(y, x);\n        let point = [\n          x - w * cos(theta),\n          y - w * sin(theta)\n        ];\n        if (!i) first2 = point;\n        add_point(point, scale);\n      }\n      add_point(first2, scale);\n      add_point(first, scale);\n    }\n\n    option.type = read_fillrule(option['fill-rule']);\n\n    return option.type\n      ? `polygon(${ option.type }, ${ points.join(',') })`\n      : `polygon(${ points.join(',') })`;\n  }\n\n  function read_fillrule(value) {\n    return (value === 'nonzero' || value == 'evenodd')\n      ? value\n      : '';\n  }\n\n  function rotate(x, y, deg) {\n    let rad = DEG * deg;\n    return [\n      x * cos(rad) - y * sin(rad),\n      y * cos(rad) + x * sin(rad)\n    ];\n  }\n\n  function translate(x, y, offset) {\n    let [dx, dy = dx] = String(offset).split(/[,\\s]/).map(Number);\n    return [\n      x + (dx || 0),\n      y + (dy || 0)\n    ];\n  }\n\n  const shapes =  {\n\n    circle() {\n      return 'circle(49%)';\n    },\n\n    triangle() {\n      return polygon({ split: 3, start: -90 }, t => [\n        cos(t) * 1.1,\n        sin(t) * 1.1 + .2\n      ]);\n    },\n\n    rhombus() {\n      return polygon({ split: 4 });\n    },\n\n    pentagon() {\n      return polygon({ split: 5, start: 54 });\n    },\n\n    hexgon() {\n      return polygon({ split: 6, start: 30 });\n    },\n\n    hexagon() {\n      return polygon({ split: 6, start: 30 });\n    },\n\n    heptagon() {\n      return polygon({ split: 7, start: -90 });\n    },\n\n    octagon() {\n      return polygon({ split: 8, start: 22.5 });\n    },\n\n    star() {\n      return polygon({ split: 5, start: 54, deg: 144 });\n    },\n\n    diamond() {\n      return 'polygon(50% 5%, 80% 50%, 50% 95%, 20% 50%)';\n    },\n\n    cross() {\n      return `polygon(\n      5% 35%,  35% 35%, 35% 5%,  65% 5%,\n      65% 35%, 95% 35%, 95% 65%, 65% 65%,\n      65% 95%, 35% 95%, 35% 65%, 5% 65%\n    )`;\n    },\n\n    clover(k = 3) {\n      k = clamp(k, 3, 5);\n      if (k == 4) k = 2;\n      return polygon({ split: 240 }, t => {\n        let x = cos(k * t) * cos(t);\n        let y = cos(k * t) * sin(t);\n        if (k == 3) x -= .2;\n        if (k == 2) {\n          x /= 1.1;\n          y /= 1.1;\n        }\n        return [x, y];\n      });\n    },\n\n    hypocycloid(k = 3) {\n      k = clamp(k, 3, 6);\n      let m = 1 - k;\n      return polygon({ scale: 1 / k  }, t => {\n        let x = m * cos(t) + cos(m * (t - PI));\n        let y = m * sin(t) + sin(m * (t - PI));\n        if (k == 3) {\n          x = x * 1.1 - .6;\n          y = y * 1.1;\n        }\n        return [x, y];\n      });\n    },\n\n    astroid() {\n      return shapes.hypocycloid(4);\n    },\n\n    infinity() {\n      return polygon(t => {\n        let a = .7 * sqrt(2) * cos(t);\n        let b = (pow(sin(t), 2) + 1);\n        return [\n          a / b,\n          a * sin(t) / b\n        ]\n      });\n    },\n\n    heart() {\n      return polygon(t => {\n        let x = .75 * pow(sin(t), 3);\n        let y =\n            cos(1 * t) * (13 / 18)\n          - cos(2 * t) * (5 / 18)\n          - cos(3 * t) / 18\n          - cos(4 * t) / 18;\n        return rotate(\n          x * 1.2,\n          (y + .2) * 1.1,\n          180\n        );\n      });\n    },\n\n    bean() {\n      return polygon(t => {\n        let [a, b] = [pow(sin(t), 3), pow(cos(t), 3)];\n        return rotate(\n          (a + b) * cos(t) * 1.3 - .45,\n          (a + b) * sin(t) * 1.3 - .45,\n          -90\n        );\n      });\n    },\n\n    bicorn() {\n      return polygon(t => rotate(\n        cos(t),\n        pow(sin(t), 2) / (2 + sin(t)) - .5,\n        180\n      ));\n    },\n\n    drop() {\n      return polygon(t => rotate(\n        sin(t),\n        (1 + sin(t)) * cos(t) / 1.4,\n        90\n      ));\n    },\n\n    pear() {\n      return polygon(t => [\n        sin(t),\n        (1 + sin(t)) * cos(t) / 1.4\n      ]);\n    },\n\n    fish() {\n      return polygon(t => [\n        cos(t) - pow(sin(t), 2) / sqrt(2),\n        sin(2 * t) / 2\n      ]);\n    },\n\n    whale() {\n      return polygon({ split: 240 }, t => {\n        let r = 3.4 * (pow(sin(t), 2) - .5) * cos(t);\n        return rotate(\n          cos(t) * r + .75,\n          sin(t) * r * 1.2,\n          180\n        );\n      });\n    },\n\n    bud(n = 3) {\n      n = clamp(n, 3, 10);\n      return polygon({ split: 240 }, t => [\n        ((1 + .2 * cos(n * t)) * cos(t)) * .8,\n        ((1 + .2 * cos(n * t)) * sin(t)) * .8\n      ]);\n    },\n\n    alien(...args) {\n      let [a = 1, b = 1, c = 1, d = 1, e = 1]\n        = args.map(n => clamp(n, 1, 9));\n      return polygon({ split: 480, type: 'evenodd' }, t => [\n        (cos(t * a) + cos(t * c) + cos(t * e)) * .31,\n        (sin(t * b) + sin(t * d) + sin(t)) * .31\n      ]);\n    }\n  };\n\n  function is_empty(value) {\n    return is_nil(value) || value === '';\n  }\n\n  function custom_shape(props) {\n    let option = Object.assign({}, props, {\n      split: clamp(parseInt(props.split) || 0, 3, 3600),\n      start: 0\n    });\n\n    if (props.degree) {\n      props.rotate= props.degree;\n    }\n\n    let px = is_empty(props.x) ? 'cos(t)' : props.x;\n    let py = is_empty(props.y) ? 'sin(t)' : props.y;\n    let pr = is_empty(props.r) ? ''       : props.r;\n\n    return polygon(option, (t, i) => {\n      let context = Object.assign({}, props, {\n        't': t,\n        'θ': t,\n        'seq': (...list) => {\n          if (!list.length) return '';\n          return list[i % list.length];\n        }\n      });\n\n      let x = calc(px, context);\n      let y = calc(py, context);\n\n      if (pr) {\n        let r = calc(pr, context);\n        x = r * Math.cos(t);\n        y = r * Math.sin(t);\n      }\n      if (props.rotate) {\n        [x, y] = rotate(x, y, Number(props.rotate) || 0);\n      }\n      if (props.origin) {\n        [x, y] = translate(x, y, props.origin);\n      }\n      return [x, y];\n    });\n  }\n\n  function is_seperator(c, no_space) {\n    if (no_space) return /[,，]/.test(c);\n    else return /[,，\\s]/.test(c);\n  }\n\n  function skip_seperator(it, no_space) {\n    while (!it.end()) {\n      if (!is_seperator(it.curr(1), no_space)) break;\n      else it.next();\n    }\n  }\n\n  function parse$3(input, no_space = false) {\n    if (is_nil(input)) input = '';\n    const it = iterator(String(input));\n    const result = [], stack = [];\n    let group = '';\n\n    while (!it.end()) {\n      let c = it.curr();\n      if (c === undefined) break;\n      if (c == '(') {\n        group += c;\n        stack.push(c);\n      }\n\n      else if (c == ')') {\n        group += c;\n        if (stack.length) {\n          stack.pop();\n        }\n      }\n\n      else if (stack.length) {\n        group += c;\n      }\n\n      else if (is_seperator(c, no_space)) {\n        result.push(group);\n        group = '';\n        skip_seperator(it, no_space);\n      }\n\n      else {\n        group += c;\n      }\n\n      it.next();\n    }\n\n    if (!is_nil(group)) {\n      result.push(group);\n    }\n\n    return result;\n  }\n\n  function parse$4(input) {\n    const it = iterator(input);\n\n    let temp = '';\n    let result = {};\n    let key = '';\n    let value = '';\n\n    while (!it.end()) {\n      let c = it.curr();\n      if (c == '/' && it.curr(1) == '*') {\n        read_comments$1(it);\n      }\n      else if (c == ':') {\n        key = temp;\n        temp = '';\n      }\n      else if (c == ';') {\n        value = temp;\n        key = key.trim();\n        value = value.trim();\n        if (key.length && value.length) {\n          result[key] = value;\n        }\n        key = value = temp = '';\n      }\n      else {\n        temp += c;\n      }\n      it.next();\n    }\n\n    key = key.trim();\n    temp = temp.trim();\n    if (key.length && temp.length) {\n      result[key] = temp;\n    }\n\n    return result;\n  }\n\n  function read_comments$1(it, flag = {}) {\n    it.next();\n    while (!it.end()) {\n      let c = it.curr();\n      if ((c = it.curr()) == '*' && it.curr(1) == '/') {\n        it.next(); it.next();\n        break;\n      }\n      it.next();\n    }\n  }\n\n  const uniform_time = {\n    'name': 'cssd-uniform-time',\n    'animation-name': 'cssd-uniform-time-animation',\n    'animation-duration': '31536000000', /* one year in ms */\n    'animation-iteration-count': 'infinite',\n    'animation-delay': '0s',\n    'animation-direction': 'normal',\n    'animation-fill-mode': 'none',\n    'animation-play-state': 'running',\n    'animation-timing-function': 'linear',\n  };\n\n  uniform_time['animation'] = `\n  ${ uniform_time['animation-duration'] }ms\n  ${ uniform_time['animation-timing-function'] }\n  ${ uniform_time['animation-delay'] }\n  ${ uniform_time['animation-iteration-count'] }\n  ${ uniform_time['animation-name'] }\n`;\n\n  function get_exposed(random) {\n    const { shuffle } = List(random);\n    const { pick, rand, nrand, unique_id } = random_func(random);\n\n    const Expose = {\n\n      index({ count }) {\n        return _ => count;\n      },\n\n      row({ y }) {\n        return _ => y;\n      },\n\n      col({ x }) {\n        return _ => x;\n      },\n\n      depth({ z }) {\n        return _ => z;\n      },\n\n      size({ grid }) {\n        return _ => grid.count;\n      },\n\n      ['size-row']({ grid }) {\n        return _ => grid.y;\n      },\n\n      ['size-col']({ grid }) {\n        return _ => grid.x;\n      },\n\n      ['size-depth']({ grid }) {\n        return _ => grid.z;\n      },\n\n      id({ x, y, z }) {\n        return _ => cell_id(x, y, z);\n      },\n\n      n({ extra }) {\n        return _ => extra ? extra[0] : '@n';\n      },\n\n      nx({ extra }) {\n        return _ => extra ? extra[1] : '@nx';\n      },\n\n      ny({ extra }) {\n        return _ => extra ? extra[2] : '@ny';\n      },\n\n      N({ extra }) {\n        return _ => extra ? extra[3] : '@N';\n      },\n\n      repeat: (\n        make_sequence('')\n      ),\n\n      multiple: (\n        make_sequence(',')\n      ),\n\n      ['multiple-with-space']: (\n        make_sequence(' ')\n      ),\n\n      pick({ context }) {\n        return expand$1((...args) => {\n          return push_stack(context, 'last_pick', pick(args));\n        });\n      },\n\n      ['pick-n']({ context, extra, position }) {\n        let counter = 'pn-counter' + position;\n        return expand$1((...args) => {\n          if (!context[counter]) context[counter] = 0;\n          context[counter] += 1;\n          let max = args.length;\n          let [ idx ] = extra || [];\n          let pos = ((idx === undefined ? context[counter] : idx) - 1) % max;\n          let value = args[pos];\n          return push_stack(context, 'last_pick', value);\n        });\n      },\n\n      ['pick-d']({ context, extra, position }) {\n        let counter = 'pd-counter' + position;\n        let values = 'pd-values' + position;\n        return expand$1((...args) => {\n          if (!context[counter]) context[counter] = 0;\n          context[counter] += 1;\n          if (!context[values]) {\n            context[values] = shuffle(args);\n          }\n          let max = args.length;\n          let [ idx ] = extra || [];\n          let pos = ((idx === undefined ? context[counter] : idx) - 1) % max;\n          let value = context[values][pos];\n          return push_stack(context, 'last_pick', value);\n        });\n      },\n\n      ['last-pick']({ context }) {\n        return (n = 1) => {\n          let stack = context.last_pick;\n          return stack ? stack.last(n) : '';\n        };\n      },\n\n      rand({ context }) {\n        return (...args) => {\n          let transform_type = args.every(is_letter)\n            ? by_charcode\n            : by_unit;\n          let value = transform_type(rand).apply(null, args);\n          return push_stack(context, 'last_rand', value);\n        };\n      },\n\n      nrand({ context }) {\n        return (...args) => {\n          let transform_type = args.every(is_letter)\n            ? by_charcode\n            : by_unit;\n          let value = transform_type(nrand).apply(null, args);\n          return push_stack(context, 'last_rand', value);\n        };\n      },\n\n      ['rand-int']({ context }) {\n        return (...args) => {\n          let transform_type = args.every(is_letter)\n            ? by_charcode\n            : by_unit;\n          let rand_int = (...args) => Math.round(rand(...args));\n          let value = transform_type(rand_int).apply(null, args);\n          return push_stack(context, 'last_rand', value);\n        }\n      },\n\n      ['nrand-int']({ context }) {\n        return (...args) => {\n          let transform_type = args.every(is_letter)\n            ? by_charcode\n            : by_unit;\n          let nrand_int = (...args) => Math.round(nrand(...args));\n          let value = transform_type(nrand_int).apply(null, args);\n          return push_stack(context, 'last_rand', value);\n        }\n      },\n\n      ['last-rand']({ context }) {\n        return (n = 1) => {\n          let stack = context.last_rand;\n          return stack ? stack.last(n) : '';\n        };\n      },\n\n      stripe() {\n        return (...input) => {\n          let colors = input.map(get_value);\n          let max = colors.length;\n          let default_count = 0;\n          let custom_sizes = [];\n          let prev;\n          if (!max) {\n            return '';\n          }\n          colors.forEach(step => {\n            let [_, size] = parse$3(step);\n            if (size !== undefined) custom_sizes.push(size);\n            else default_count += 1;\n          });\n          let default_size = custom_sizes.length\n            ? `(100% - ${custom_sizes.join(' - ')}) / ${default_count}`\n            : `100% / ${max}`;\n          return colors\n            .map((step, i) => {\n              if (custom_sizes.length) {\n                let [color, size] = parse$3(step);\n                let prefix = prev ? (prev + ' + ') : '';\n                prev = prefix + (size !== undefined ? size : default_size);\n                return `${color} 0 calc(${ prev })`\n              }\n              return `${step} 0 ${100 / max * (i + 1)}%`\n            })\n            .join(',');\n        }\n      },\n\n      calc() {\n        return value => calc(get_value(value));\n      },\n\n      hex() {\n        return value => parseInt(get_value(value)).toString(16);\n      },\n\n      svg: lazy(input => {\n        if (input === undefined) return '';\n        let svg = normalize_svg(get_value(input()).trim());\n        return create_svg_url(svg);\n      }),\n\n      ['svg-filter']: lazy(input => {\n        if (input === undefined) return '';\n        let id = unique_id('filter-');\n        let svg = normalize_svg(get_value(input()).trim())\n          .replace(\n            /<filter([\\s>])/,\n            `<filter id=\"${ id }\"$1`\n          );\n        return create_svg_url(svg, id);\n      }),\n\n      var() {\n        return value => `var(${ get_value(value) })`;\n      },\n\n      t() {\n        return value => `var(--${ uniform_time.name })`;\n      },\n\n      shape() {\n        return memo('shape-function', (type = '', ...args) => {\n          type = String(type).trim();\n          if (!type.length) return 'polygon()';\n          if (typeof shapes[type] === 'function') {\n            return shapes[type](args);\n          } else {\n            let commands = type;\n            let rest = args.join(',');\n            if (rest.length) {\n              commands = type + ',' + rest;\n            }\n            let config = parse$4(commands);\n            return custom_shape(config);\n          }\n        });\n      },\n\n      doodle() {\n        return value => value;\n      },\n\n      shaders() {\n        return value => value;\n      },\n\n      path() {\n        return value => value;\n      },\n\n    };\n\n    function make_sequence(c) {\n      return lazy((n, action) => {\n        if (!action || !n) return '';\n        let count = get_value(n());\n        return sequence(count, (i, x, y, max) => get_value(action(i, x, y, max))).join(c);\n      });\n    }\n\n    function push_stack(context, name, value) {\n      if (!context[name]) context[name] = new Stack();\n      context[name].push(value);\n      return value;\n    }\n\n    return alias_for(Expose, {\n      'm': 'multiple',\n      'M': 'multiple-with-space',\n\n      'r':    'rand',\n      'rn':   'nrand',\n      'ri':   'rand-int',\n      'rni':  'nrand-int',\n      'lr':   'last-rand',\n\n      'p':  'pick',\n      'pn': 'pick-n',\n      'pd': 'pick-d',\n      'lp': 'last-pick',\n\n      'rep': 'repeat',\n\n      'i': 'index',\n      'x': 'col',\n      'y': 'row',\n      'z': 'depth',\n\n      'I': 'size',\n      'X': 'size-col',\n      'Y': 'size-row',\n      'Z': 'size-depth',\n\n      // legacy names\n      'nr': 'rn',\n      'nri': 'nri',\n      'ms': 'multiple-with-space',\n      's':  'size',\n      'sx': 'size-col',\n      'sy': 'size-row',\n      'sz': 'size-depth',\n      'size-x': 'size-col',\n      'size-y': 'size-row',\n      'size-z': 'size-depth',\n      'multi': 'multiple',\n      'pick-by-turn': 'pick-n',\n      'max-row': 'size-row',\n      'max-col': 'size-col',\n\n      // error prone\n      'stripes': 'stripe',\n      'strip':   'stripe',\n    });\n  }\n\n  let all = [];\n\n  function get_props(arg) {\n    if (!all.length) {\n      let props = new Set();\n      for (let n in document.head.style) {\n        if (!n.startsWith('-')) {\n          props.add(n.replace(/[A-Z]/g, '-$&').toLowerCase());\n        }\n      }\n      if (!props.has('grid-gap')) {\n        props.add('grid-gap');\n      }\n      all = Array.from(props);\n    }\n    return (arg && arg.test)\n      ? all.filter(n => arg.test(n))\n      : all;\n  }\n\n  function build_mapping(prefix) {\n    let reg = new RegExp(`\\\\-?${ prefix }\\\\-?`);\n    return get_props(reg)\n      .map(n => n.replace(reg, ''))\n      .reduce((obj, n) => { return obj[n] = n, obj }, {});\n  }\n\n  const props_webkit_mapping = build_mapping('webkit');\n  const props_moz_mapping = build_mapping('moz');\n\n  function prefixer(prop, rule) {\n    if (props_webkit_mapping[prop]) {\n      return `-webkit-${ rule } ${ rule }`;\n    }\n    else if (props_moz_mapping[prop]) {\n      return `-moz-${ rule } ${ rule }`;\n    }\n    return rule;\n  }\n\n  const presets = {\n\n   '4a0': [ 1682, 2378 ],\n   '2a0': [ 1189, 1682 ],\n    a0:   [ 841, 1189 ],\n    a1:   [ 594, 841 ],\n    a2:   [ 420, 594 ],\n    a3:   [ 297, 420 ],\n    a4:   [ 210, 297 ],\n    a5:   [ 148, 210 ],\n    a6:   [ 105, 148 ],\n    a7:   [ 74, 105 ],\n    a8:   [ 52, 74 ],\n    a9:   [ 37, 52 ],\n    a10:  [ 26, 37 ],\n\n    b0:  [ 1000, 1414 ],\n    b1:  [ 707, 1000 ],\n    b2:  [ 500, 707 ],\n    b3:  [ 353, 500 ],\n    b4:  [ 250, 353 ],\n    b5:  [ 176, 250 ],\n    b6:  [ 125, 176 ],\n    b7:  [ 88, 125 ],\n    b8:  [ 62, 88 ],\n    b9:  [ 44, 62 ],\n    b10: [ 31, 44 ],\n    b11: [ 22, 32 ],\n    b12: [ 16, 22 ],\n\n    c0:  [ 917, 1297 ],\n    c1:  [ 648, 917 ],\n    c2:  [ 458, 648 ],\n    c3:  [ 324, 458 ],\n    c4:  [ 229, 324 ],\n    c5:  [ 162, 229 ],\n    c6:  [ 114, 162 ],\n    c7:  [ 81, 114 ],\n    c8:  [ 57, 81 ],\n    c9:  [ 40, 57 ],\n    c10: [ 28, 40 ],\n    c11: [ 22, 32 ],\n    c12: [ 16, 22 ],\n\n    d0: [ 764, 1064 ],\n    d1: [ 532, 760 ],\n    d2: [ 380, 528 ],\n    d3: [ 264, 376 ],\n    d4: [ 188, 260 ],\n    d5: [ 130, 184 ],\n    d6: [ 92, 126 ],\n\n    letter:         [ 216, 279 ],\n    legal:          [ 216, 356 ],\n    'junior-legal': [ 203, 127 ],\n    ledger:         [ 279, 432 ],\n    tabloid:        [ 279, 432 ],\n    executive:      [ 190, 254 ],\n\n    postcard:        [ 100, 148 ],\n    'business-card': [ 54, 90 ],\n\n    poster: [ 390, 540 ],\n  };\n\n  const modes = {\n    portrait: 'p',\n    pt: 'p',\n    p: 'p',\n\n    landscape: 'l',\n    ls: 'l',\n    l: 'l',\n  };\n\n  const unit = 'mm';\n\n  function get_preset(name, mode) {\n    name = String(name).toLowerCase();\n\n    // Default to landscape mode\n    let [h, w] = presets[name] || [];\n\n    if (modes[mode] == 'p') {\n      [w, h] = [h, w];\n    }\n\n    return [w, h].map(n => n + unit);\n  }\n\n  function is_preset(name) {\n    return !!presets[name];\n  }\n\n  var Property = {\n\n    ['@size'](value, { is_special_selector }) {\n      let [w, h = w] = parse$3(value);\n      if (is_preset(w)) {\n        [w, h] = get_preset(w, h);\n      }\n      return `\n      width: ${ w };\n      height: ${ h };\n      ${ is_special_selector ? '' : `\n        --internal-cell-width: ${ w };\n        --internal-cell-height: ${ h };\n      `}\n    `;\n    },\n\n    ['@min-size'](value) {\n      let [w, h = w] = parse$3(value);\n      return `min-width: ${ w }; min-height: ${ h };`;\n    },\n\n    ['@max-size'](value) {\n      let [w, h = w] = parse$3(value);\n      return `max-width: ${ w }; max-height: ${ h };`;\n    },\n\n    ['@place-cell']: (() => {\n      let map_left_right = {\n        'center': '50%', '0': '0%',\n        'left': '0%', 'right': '100%',\n        'top': '50%', 'bottom': '50%'\n      };\n      let map_top_bottom = {\n        'center': '50%', '0': '0%',\n        'top': '0%', 'bottom': '100%',\n        'left': '50%', 'right': '50%',\n      };\n\n      return value => {\n        let [left, top = '50%'] = parse$3(value);\n        left = map_left_right[left] || left;\n        top = map_top_bottom[top] || top;\n        const cw = 'var(--internal-cell-width, 25%)';\n        const ch = 'var(--internal-cell-height, 25%)';\n        return `\n        position: absolute;\n        left: ${ left };\n        top: ${ top };\n        width: ${ cw };\n        height: ${ ch };\n        margin-left: calc(${ cw } / -2) !important;\n        margin-top: calc(${ ch } / -2) !important;\n        grid-area: unset !important;\n      `;\n      }\n    })(),\n\n    ['@grid'](value, options) {\n      let [grid, ...size] = value.split('/').map(s => s.trim());\n      size = size.join(' / ');\n      return {\n        grid: parse_grid(grid),\n        size: size ? this['@size'](size, options) : ''\n      };\n    },\n\n    ['@shape']: memo('shape-property', value => {\n      let [type, ...args] = parse$3(value);\n      let prop = 'clip-path';\n      if (typeof shapes[type] !== 'function') return '';\n      let rules = `${ prop }: ${ shapes[type](...args) };`;\n      return prefixer(prop, rules) + 'overflow: hidden;';\n    }),\n\n    ['@use'](rules) {\n      if (rules.length > 2) {\n        return rules;\n      }\n    }\n\n  };\n\n  function build_expr(expr) {\n    return n => String(expr)\n      .replace(/(\\d+)(n)/g, '$1*' + n)\n      .replace(/n/g, n);\n  }\n\n  function nth(input, curr, max) {\n    let expr = build_expr(input);\n    for (let i = 0; i <= max; ++i) {\n      if (calc(expr(i)) == curr) return true;\n    }\n  }\n\n  const is$1 = {\n    even: n => !(n % 2),\n    odd:  n => !!(n % 2)\n  };\n\n  function even_or_odd(expr) {\n    return /^(even|odd)$/.test(expr);\n  }\n\n  function Selector(random) {\n\n    return {\n\n      at({ x, y }) {\n        return (x1, y1) => (x == x1 && y == y1);\n      },\n\n      nth({ count, grid }) {\n        return (...exprs) => exprs.some(expr =>\n          even_or_odd(expr)\n            ? is$1[expr](count)\n            : nth(expr, count, grid.count)\n        );\n      },\n\n      row({ y, grid }) {\n        return (...exprs) => exprs.some(expr =>\n          even_or_odd(expr)\n            ? is$1[expr](y)\n            : nth(expr, y, grid.y)\n        );\n      },\n\n      col({ x, grid }) {\n        return (...exprs) => exprs.some(expr =>\n          even_or_odd(expr)\n            ? is$1[expr](x)\n            : nth(expr, x, grid.x)\n        );\n      },\n\n      even({ count, grid, y }) {\n        return arg => {\n          if (arg === 'cross' && is$1.even(grid.x)) {\n            let m = is$1.even(y) ? 'odd' : 'even';\n            return is$1[m](count);\n          } else {\n            return is$1.even(count);\n          }\n        }\n      },\n\n      odd({ count, grid, y}) {\n        return arg => {\n          if (arg === 'cross' && is$1.even(grid.x)) {\n            let m = is$1.even(y) ? 'even' : 'odd';\n            return is$1[m](count);\n          } else {\n            return is$1.odd(count);\n          }\n        }\n      },\n\n      random() {\n        return (ratio = .5) => {\n          if (ratio >= 1 && ratio <= 0) ratio = .5;\n          return random() < ratio;\n        }\n      }\n\n    }\n  }\n\n  // Expose all Math functions and constants.\n  const methods = Object.getOwnPropertyNames(Math);\n\n  var MathFunc = methods.reduce((expose, n) => {\n    expose[n] = () => (...args) => {\n      args = args.map(get_value);\n      if (typeof Math[n] === 'number') return Math[n];\n      return Math[n].apply(null, args.map(calc));\n    };\n    return expose;\n  }, {});\n\n  const initial = {\n    length: '0px',\n    number: 0,\n    color: 'black',\n    url: 'url()',\n    image: 'url()',\n    integer: 0,\n    angle: '0deg',\n    time: '0ms',\n    resolution: '0dpi',\n    percentage: '0%',\n    'length-percentage': '0%',\n    'transform-function': 'translate(0)',\n    'transform-list': 'translate(0)',\n    'custom-ident': '_'\n  };\n\n  function get_definition(name) {\n    let type = String(name).substr(2).split('-')[0];\n    if (initial[type] !== undefined) {\n      return {\n        name: name,\n        syntax: `<${type}> | <${type}>+ | <${type}>#`,\n        initialValue: initial[type],\n        inherits: false\n      }\n    }\n  }\n\n  let { join, make_array, remove_empty_values } = List();\n\n  function is_host_selector(s) {\n    return /^\\:(host|doodle)/.test(s);\n  }\n\n  function is_parent_selector(s) {\n    return /^\\:(container|parent)/.test(s);\n  }\n\n  function is_special_selector(s) {\n    return is_host_selector(s) || is_parent_selector(s);\n  }\n\n  class Rules {\n\n    constructor(tokens, random) {\n      this.tokens = tokens;\n      this.rules = {};\n      this.props = {};\n      this.keyframes = {};\n      this.grid = null;\n      this.is_grid_defined = false;\n      this.coords = [];\n      this.doodles = {};\n      this.shaders = {};\n      this.paths = {};\n      this.reset();\n      this.Func = get_exposed(random);\n      this.Selector = Selector(random);\n      this.custom_properties = {};\n      this.uniforms = {};\n      this.unique_id = random_func(random).unique_id;\n    }\n\n    reset() {\n      this.styles = {\n        host: '',\n        container: '',\n        cells: '',\n        keyframes: ''\n      };\n      this.coords = [];\n      this.doodles = {};\n      for (let key in this.rules) {\n        if (key.startsWith('#c')) {\n          delete this.rules[key];\n        }\n      }\n    }\n\n    add_rule(selector, rule) {\n      let rules = this.rules[selector];\n      if (!rules) {\n        rules = this.rules[selector] = [];\n      }\n      rules.push.apply(rules, make_array(rule));\n    }\n\n    pick_func(name) {\n      return this.Func[name] || MathFunc[name];\n    }\n\n    apply_func(fn, coords, args) {\n      let _fn = fn(...make_array(coords));\n      let input = [];\n      args.forEach(arg => {\n        let type = typeof arg.value;\n        let is_string_or_number = (type === 'number' || type === 'string');\n\n        if (!arg.cluster && (is_string_or_number)) {\n          input.push(...parse$3(arg.value, true));\n        }\n        else {\n          if (typeof arg === 'function') {\n            input.push(arg);\n          }\n          else if (!is_nil(arg.value)) {\n            let value = get_value(arg.value);\n            input.push(value);\n          }\n        }\n      });\n      input = remove_empty_values(input);\n      let result = _fn(...make_array(input));\n      return result;\n    }\n\n    compose_aname(...args) {\n      return args.join('-');\n    }\n\n    compose_selector({ x, y, z}, pseudo = '') {\n      return `#${ cell_id(x, y, z) }${ pseudo }`;\n    }\n\n    is_composable(name) {\n      return ['doodle', 'shaders'].includes(name);\n    }\n\n    compose_argument(argument, coords, extra = []) {\n      let result = argument.map(arg => {\n        if (arg.type === 'text') {\n          return arg.value;\n        }\n        else if (arg.type === 'func') {\n          let fname = arg.name.substr(1);\n          let fn = this.pick_func(fname);\n\n          if (typeof fn === 'function') {\n            if (fname === 't') {\n              this.uniforms.time = true;\n            }\n            if (this.is_composable(fname)) {\n              let value = get_value((arg.arguments[0] || [])[0]);\n              if (!is_nil(value)) {\n                switch (fname) {\n                  case 'doodle':\n                    return this.compose_doodle(value);\n                  case 'shaders':\n                    return this.compose_shaders(value, coords);\n                }\n              }\n            }\n            coords.extra = extra;\n            coords.position = arg.position;\n            let args = arg.arguments.map(n => {\n              return fn.lazy\n                ? (...extra) => this.compose_argument(n, coords, extra)\n                : this.compose_argument(n, coords, extra);\n            });\n            let value = this.apply_func(fn, coords, args);\n            if (fname == 'path') {\n              return this.compose_path(value);\n            }\n            return value;\n          }\n        }\n      });\n\n      return {\n        cluster: argument.cluster,\n        value: (result.length >= 2 ? ({ value: result.join('') }) : result[0])\n      }\n    }\n\n    compose_doodle(doodle) {\n      let id = this.unique_id('doodle');\n      this.doodles[id] = doodle;\n      return '${' + id + '}';\n    }\n\n    compose_shaders(shader, {x, y, z}) {\n      let id = this.unique_id('shader');\n      this.shaders[id] = {\n        shader,\n        cell: cell_id(x, y, z)\n      };\n      return '${' + id + '}';\n    }\n\n    compose_path(commands) {\n      let id = this.unique_id('path');\n      this.paths[id] = {\n        id,\n        commands\n      };\n      return '${' + id + '}';\n    }\n\n    compose_value(value, coords) {\n      if (!Array.isArray(value)) {\n        return '';\n      }\n      return value.reduce((result, val) => {\n        switch (val.type) {\n          case 'text': {\n            result += val.value;\n            break;\n          }\n          case 'func': {\n            let fname = val.name.substr(1);\n            let fn = this.pick_func(fname);\n            if (typeof fn === 'function') {\n              if (fname === 't') {\n                this.uniforms.time = true;\n              }\n              if (this.is_composable(fname)) {\n                let value = get_value((val.arguments[0] || [])[0]);\n                if (!is_nil(value)) {\n                  switch (fname) {\n                    case 'doodle':\n                      result += this.compose_doodle(value); break;\n                    case 'shaders':\n                      result += this.compose_shaders(value, coords); break;\n                  }\n                }\n              } else {\n                coords.position = val.position;\n                let args = val.arguments.map(arg => {\n                  return fn.lazy\n                    ? (...extra) => this.compose_argument(arg, coords, extra)\n                    : this.compose_argument(arg, coords);\n                });\n\n                let output = this.apply_func(fn, coords, args);\n                if (!is_nil(output)) {\n                  if (fname == 'path') {\n                    result += this.compose_path(output);\n                  } else {\n                    result += output;\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result;\n      }, '');\n    }\n\n    compose_rule(token, _coords, selector) {\n      let coords = Object.assign({}, _coords);\n      let prop = token.property;\n      let value_group = token.value.reduce((ret, v) => {\n        let composed = this.compose_value(v, coords);\n        if (composed) ret.push(composed);\n        return ret;\n      }, []);\n\n      let value = value_group.join(', ');\n\n      if (/^animation(\\-name)?$/.test(prop)) {\n        this.props.has_animation = true;\n\n        if (is_host_selector(selector)) {\n          let prefix = uniform_time[prop];\n          if (prefix && value) {\n            value =  prefix + ',' + value;\n          }\n        }\n\n        if (coords.count > 1) {\n          let { count } = coords;\n          switch (prop) {\n            case 'animation-name': {\n              value = value_group\n                .map(n => this.compose_aname(n, count))\n                .join(', ');\n              break;\n            }\n            case 'animation': {\n              value = value_group\n                .map(n => {\n                  let group = (n || '').split(/\\s+/);\n                  group[0] = this.compose_aname(group[0], count);\n                  return group.join(' ');\n                })\n                .join(', ');\n            }\n          }\n        }\n      }\n\n      if (prop === 'content') {\n        if (!/[\"']|^none$|^(var|counter|counters|attr)\\(/.test(value)) {\n          value = `'${ value }'`;\n        }\n      }\n\n      if (prop === 'transition') {\n        this.props.has_transition = true;\n      }\n\n      let rule = `${ prop }: ${ value };`;\n      rule = prefixer(prop, rule);\n\n      if (prop === 'clip-path') {\n        // fix clip bug\n        rule += ';overflow: hidden;';\n      }\n\n      if (prop === 'width' || prop === 'height') {\n        if (!is_special_selector(selector)) {\n          rule += `--internal-cell-${ prop }: ${ value };`;\n        }\n      }\n\n      if (prop === 'background' && value.includes('shader')) {\n        rule += 'background-size: 100% 100%;';\n      }\n\n      if (/^\\-\\-/.test(prop)) {\n        this.custom_properties[prop] = value;\n      }\n\n      if (Property[prop]) {\n        let transformed = Property[prop](value, {\n          is_special_selector: is_special_selector(selector)\n        });\n        switch (prop) {\n          case '@grid': {\n            if (is_host_selector(selector)) {\n              rule = transformed.size || '';\n            } else {\n              rule = '';            if (!this.is_grid_defined) {\n                transformed = Property[prop](value, {\n                  is_special_selector: true\n                });\n                this.add_rule(':host', transformed.size || '');\n              }\n            }\n            this.grid = coords.grid;\n            this.is_grid_defined = true;\n            break;\n          }\n          case '@place-cell': {\n            if (!is_host_selector(selector)) {\n              rule = transformed;\n            }\n            break;\n          }\n          case '@use': {\n            if (token.value.length) {\n              this.compose(coords, token.value);\n            }\n            rule = '';\n            break;\n          }\n          default: {\n            rule = transformed;\n          }\n        }\n      }\n\n      return rule;\n    }\n\n    pre_compose_rule(token, _coords) {\n      let coords = Object.assign({}, _coords);\n      let prop = token.property;\n\n      switch (prop) {\n        case '@grid': {\n          let value_group = token.value.reduce((ret, v) => {\n            let composed = this.compose_value(v, coords);\n            if (composed) ret.push(composed);\n            return ret;\n          }, []);\n          let value = value_group.join(', ');\n          let transformed = Property[prop](value, {});\n          this.grid = transformed.grid;\n          break;\n        }\n        case '@use': {\n          if (token.value.length) {\n            this.pre_compose(coords, token.value);\n          }\n          break;\n        }\n      }\n    }\n\n    pre_compose(coords, tokens) {\n      (tokens || this.tokens).forEach(token => {\n        switch (token.type) {\n          case 'rule': {\n            this.pre_compose_rule(token, coords);\n            break;\n          }\n          case 'pseudo': {\n            if (is_host_selector(token.selector)) {\n              (token.styles || []).forEach(token => {\n                this.pre_compose_rule(token, coords);\n              });\n            }\n            break;\n          }\n        }\n      });\n    }\n\n    compose(coords, tokens, initial) {\n      this.coords.push(coords);\n      (tokens || this.tokens).forEach((token, i) => {\n        if (token.skip) return false;\n        if (initial && this.grid) return false;\n\n        switch (token.type) {\n          case 'rule': {\n            this.add_rule(\n              this.compose_selector(coords),\n              this.compose_rule(token, coords)\n            );\n            break;\n          }\n\n          case 'pseudo': {\n            if (token.selector.startsWith(':doodle')) {\n              token.selector = token.selector.replace(/^\\:+doodle/, ':host');\n            }\n            let special = is_special_selector(token.selector);\n            if (special) {\n              token.skip = true;\n            }\n            token.selector.split(',').forEach(selector => {\n              let pseudo = token.styles.map(s =>\n                this.compose_rule(s, coords, selector)\n              );\n              let composed = special\n                ? selector\n                : this.compose_selector(coords, selector);\n              this.add_rule(composed, pseudo);\n            });\n\n            break;\n          }\n\n          case 'cond': {\n            let fn = this.Selector[token.name.substr(1)];\n            if (fn) {\n              let args = token.arguments.map(arg => {\n                return this.compose_argument(arg, coords);\n              });\n              let result = this.apply_func(fn, coords, args);\n              if (result) {\n                this.compose(coords, token.styles);\n              }\n            }\n            break;\n          }\n\n          case 'keyframes': {\n            if (!this.keyframes[token.name]) {\n              this.keyframes[token.name] = coords => `\n              ${ join(token.steps.map(step => `\n                ${ step.name } {\n                  ${ join(\n                    step.styles.map(s => this.compose_rule(s, coords))\n                  )}\n                }\n              `)) }\n            `;\n            }\n          }\n        }\n      });\n    }\n\n    output() {\n      Object.keys(this.rules).forEach((selector, i) => {\n        if (is_parent_selector(selector)) {\n          this.styles.container += `\n          .container {\n            ${ join(this.rules[selector]) }\n          }\n        `;\n        } else {\n          let target = is_host_selector(selector) ? 'host' : 'cells';\n          let value = join(this.rules[selector]).trim();\n          let name = (target === 'host') ? `${ selector }, .host` : selector;\n          this.styles[target] += `${ name } { ${ value  } }`;\n        }\n      });\n\n      let keyframes = Object.keys(this.keyframes);\n\n      if (this.uniforms.time) {\n        this.styles.container += `\n        :host, .host {\n          animation: ${ uniform_time.animation };\n        }\n      `;\n        this.styles.keyframes += `\n       @keyframes ${ uniform_time['animation-name'] } {\n         from { --${ uniform_time.name }: 0 }\n         to { --${ uniform_time.name }: ${ uniform_time['animation-duration'] } }\n       }\n      `;\n      }\n\n      this.coords.forEach((coords, i) => {\n        keyframes.forEach(name => {\n          let aname = this.compose_aname(name, coords.count);\n          this.styles.keyframes += `\n          ${ maybe(i === 0,\n            `@keyframes ${ name } {\n              ${ this.keyframes[name](coords) }\n            }`\n          )}\n          @keyframes ${ aname } {\n            ${ this.keyframes[name](coords) }\n          }\n        `;\n        });\n      });\n\n      let definitions = [];\n      Object.keys(this.custom_properties).forEach(name => {\n        let def = get_definition(name);\n        if (def) {\n          definitions.push(def);\n        }\n      });\n\n      return {\n        props: this.props,\n        styles: this.styles,\n        grid: this.grid,\n        doodles: this.doodles,\n        shaders: this.shaders,\n        paths: this.paths,\n        definitions: definitions,\n        uniforms: this.uniforms\n      }\n    }\n\n  }\n\n  function generator(tokens, grid_size, random) {\n    let rules = new Rules(tokens, random);\n    let context = {};\n\n    rules.pre_compose({\n      x: 1, y: 1, z: 1, count: 1, context: {},\n      grid: { x: 1, y: 1, z: 1, count: 1 }\n    });\n\n    let { grid } = rules.output();\n    if (grid) grid_size = grid;\n    rules.reset();\n\n    if (grid_size.z == 1) {\n      for (let y = 1, count = 0; y <= grid_size.y; ++y) {\n        for (let x = 1; x <= grid_size.x; ++x) {\n          rules.compose({\n            x, y, z: 1,\n            count: ++count, grid: grid_size, context\n          });\n        }\n      }\n    }\n    else {\n      for (let z = 1, count = 0; z <= grid_size.z; ++z) {\n        rules.compose({\n          x: 1, y: 1, z,\n          count: ++count, grid: grid_size, context\n        });\n      }\n    }\n\n    return rules.output();\n  }\n\n  /*\n  Copyright 2019 David Bau.\n  Permission is hereby granted, free of charge, to any person obtaining\n  a copy of this software and associated documentation files (the\n  \"Software\"), to deal in the Software without restriction, including\n  without limitation the rights to use, copy, modify, merge, publish,\n  distribute, sublicense, and/or sell copies of the Software, and to\n  permit persons to whom the Software is furnished to do so, subject to\n  the following conditions:\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n  */\n\n  var global = window;\n  var math = Math;\n  var pool = [];\n\n  //\n  // The following constants are related to IEEE 754 limits.\n  //\n\n  var width = 256,        // each RC4 output is 0 <= x < 256\n      chunks = 6,         // at least six RC4 outputs for each double\n      digits = 52,        // there are 52 significant digits in a double\n      rngname = 'random', // rngname: name for Math.random and Math.seedrandom\n      startdenom = math.pow(width, chunks),\n      significance = math.pow(2, digits),\n      overflow = significance * 2,\n      mask = width - 1,\n      nodecrypto;         // node.js crypto module, initialized at the bottom.\n\n  //\n  // seedrandom()\n  // This is the seedrandom function described above.\n  //\n  function seedrandom(seed, options, callback) {\n    var key = [];\n    options = (options == true) ? { entropy: true } : (options || {});\n\n    // Flatten the seed string or build one from local entropy if needed.\n    var shortseed = mixkey(flatten(\n      options.entropy ? [seed, tostring(pool)] :\n      (seed == null) ? autoseed() : seed, 3), key);\n\n    // Use the seed to initialize an ARC4 generator.\n    var arc4 = new ARC4(key);\n\n    // This function returns a random double in [0, 1) that contains\n    // randomness in every bit of the mantissa of the IEEE 754 value.\n    var prng = function() {\n      var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48\n          d = startdenom,                 //   and denominator d = 2 ^ 48.\n          x = 0;                          //   and no 'extra last byte'.\n      while (n < significance) {          // Fill up all significant digits by\n        n = (n + x) * width;              //   shifting numerator and\n        d *= width;                       //   denominator and generating a\n        x = arc4.g(1);                    //   new least-significant-byte.\n      }\n      while (n >= overflow) {             // To avoid rounding up, before adding\n        n /= 2;                           //   last byte, shift everything\n        d /= 2;                           //   right using integer math until\n        x >>>= 1;                         //   we have exactly the desired bits.\n      }\n      return (n + x) / d;                 // Form the number within [0, 1).\n    };\n\n    prng.int32 = function() { return arc4.g(4) | 0; };\n    prng.quick = function() { return arc4.g(4) / 0x100000000; };\n    prng.double = prng;\n\n    // Mix the randomness into accumulated entropy.\n    mixkey(tostring(arc4.S), pool);\n\n    // Calling convention: what to return as a function of prng, seed, is_math.\n    return (options.pass || callback ||\n        function(prng, seed, is_math_call, state) {\n          if (state) {\n            // Load the arc4 state from the given state if it has an S array.\n            if (state.S) { copy(state, arc4); }\n            // Only provide the .state method if requested via options.state.\n            prng.state = function() { return copy(arc4, {}); };\n          }\n\n          // If called as a method of Math (Math.seedrandom()), mutate\n          // Math.random because that is how seedrandom.js has worked since v1.0.\n          if (is_math_call) { math[rngname] = prng; return seed; }\n\n          // Otherwise, it is a newer calling convention, so return the\n          // prng directly.\n          else return prng;\n        })(\n    prng,\n    shortseed,\n    'global' in options ? options.global : (this == math),\n    options.state);\n  }\n\n  //\n  // ARC4\n  //\n  // An ARC4 implementation.  The constructor takes a key in the form of\n  // an array of at most (width) integers that should be 0 <= x < (width).\n  //\n  // The g(count) method returns a pseudorandom integer that concatenates\n  // the next (count) outputs from ARC4.  Its return value is a number x\n  // that is in the range 0 <= x < (width ^ count).\n  //\n  function ARC4(key) {\n    var t, keylen = key.length,\n        me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];\n\n    // The empty key [] is treated as [0].\n    if (!keylen) { key = [keylen++]; }\n\n    // Set up S using the standard key scheduling algorithm.\n    while (i < width) {\n      s[i] = i++;\n    }\n    for (i = 0; i < width; i++) {\n      s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];\n      s[j] = t;\n    }\n\n    // The \"g\" method returns the next (count) outputs as one number.\n    (me.g = function(count) {\n      // Using instance members instead of closure state nearly doubles speed.\n      var t, r = 0,\n          i = me.i, j = me.j, s = me.S;\n      while (count--) {\n        t = s[i = mask & (i + 1)];\n        r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];\n      }\n      me.i = i; me.j = j;\n      return r;\n      // For robust unpredictability, the function call below automatically\n      // discards an initial batch of values.  This is called RC4-drop[256].\n      // See http://google.com/search?q=rsa+fluhrer+response&btnI\n    })(width);\n  }\n\n  //\n  // copy()\n  // Copies internal state of ARC4 to or from a plain object.\n  //\n  function copy(f, t) {\n    t.i = f.i;\n    t.j = f.j;\n    t.S = f.S.slice();\n    return t;\n  }\n  //\n  // flatten()\n  // Converts an object tree to nested arrays of strings.\n  //\n  function flatten(obj, depth) {\n    var result = [], typ = (typeof obj), prop;\n    if (depth && typ == 'object') {\n      for (prop in obj) {\n        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}\n      }\n    }\n    return (result.length ? result : typ == 'string' ? obj : obj + '\\0');\n  }\n\n  //\n  // mixkey()\n  // Mixes a string seed into a key that is an array of integers, and\n  // returns a shortened string seed that is equivalent to the result key.\n  //\n  function mixkey(seed, key) {\n    var stringseed = seed + '', smear, j = 0;\n    while (j < stringseed.length) {\n      key[mask & j] =\n        mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));\n    }\n    return tostring(key);\n  }\n\n  //\n  // autoseed()\n  // Returns an object for autoseeding, using window.crypto and Node crypto\n  // module if available.\n  //\n  function autoseed() {\n    try {\n      var out;\n      if (nodecrypto && (out = nodecrypto.randomBytes)) ; else {\n        out = new Uint8Array(width);\n        (global.crypto || global.msCrypto).getRandomValues(out);\n      }\n      return tostring(out);\n    } catch (e) {\n      var browser = global.navigator,\n          plugins = browser && browser.plugins;\n      return [+new Date, global, plugins, global.screen, tostring(pool)];\n    }\n  }\n\n  //\n  // tostring()\n  // Converts an array of charcodes to a string\n  //\n  function tostring(a) {\n    return String.fromCharCode.apply(0, a);\n  }\n\n  //\n  // When seedrandom.js is loaded, we immediately mix a few bits\n  // from the built-in RNG into the entropy pool.  Because we do\n  // not want to interfere with deterministic PRNG state later,\n  // seedrandom will not call math.random on its own again after\n  // initialization.\n  //\n  mixkey(math.random(), pool);\n\n  function create_shader(gl, type, source) {\n    let shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    return shader;\n  }\n  function create_program(gl, vss, fss) {\n    let vs = create_shader(gl, gl.VERTEX_SHADER, vss);\n    let fs = create_shader(gl, gl.FRAGMENT_SHADER, fss);\n    let prog = gl.createProgram();\n    gl.attachShader(prog, vs);\n    gl.attachShader(prog, fs);\n    gl.linkProgram(prog);\n    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {\n      console.warn('Link failed: ' + gl.getProgramInfoLog(prog));\n      console.warn('vs info-log: ' + gl.getShaderInfoLog(vs));\n      console.warn('fs info-log: ' + gl.getShaderInfoLog(fs));\n    }\n    return prog;\n  }\n\n  function add_uniform(fragment, uniform) {\n    if (!fragment.includes(uniform)) {\n      return uniform + '\\n' + fragment;\n    }\n    return fragment;\n  }\n\n  const fragment_head = `\n  precision highp float;\n`;\n\n  const default_vertex_shader = `\n  attribute vec4 position;\n  void main() {\n    gl_Position = position;\n  }\n`;\n\n  /* https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL */\n  function load_texture(gl, image, i) {\n    const texture = gl.createTexture();\n    gl.activeTexture(gl['TEXTURE' + i]);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  }\n\n  function draw_shader(shaders, width, height) {\n    let canvas = document.createElement('canvas');\n    let ratio = window.devicePixelRatio || 1;\n    width *= ratio;\n    height *= ratio;\n    canvas.width = width;\n    canvas.height = height;\n\n    let gl = canvas.getContext('webgl')\n      || canvas.getContext('exprimental-webgl');\n    if (!gl) return '';\n\n    // resolution uniform\n    let fragment = add_uniform(shaders.fragment || '', 'uniform vec2 u_resolution;');\n    // texture uniform\n    shaders.textures.forEach(n => {\n      let uniform = `uniform sampler2D ${ n.name };`;\n      fragment =  add_uniform(fragment, uniform);\n    });\n\n    let program = create_program(\n      gl,\n      shaders.vertex || default_vertex_shader,\n      fragment_head + fragment\n    );\n\n    /* position in vertex shader */\n    let positionAttributeLocation = gl.getAttribLocation(program, 'position');\n    let positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    let vertices = [-1, -1, -1, 1, 1, -1, 1, 1, -1, 1, 1, -1];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.useProgram(program);\n\n    /* resolve uniforms */\n    gl.uniform2fv(gl.getUniformLocation(program, \"u_resolution\"), [width, height]);\n    shaders.textures.forEach((n, i) => {\n      load_texture(gl, n.value, i);\n      gl.uniform1i(gl.getUniformLocation(program, n.name), i);\n    });\n\n    // two triangles to form a rectangle\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n    // resolve image data in 72dpi :(\n    return Promise.resolve(canvas.toDataURL());\n  }\n\n  function get_all_variables(element) {\n    let ret = {};\n    if (element.computedStyleMap) {\n      for (let [prop, value] of element.computedStyleMap()) {\n        if (prop.startsWith('--')) {\n          ret[prop] = value[0][0];\n        }\n      }\n    } else {\n      let styles = getComputedStyle(element);\n      for (let prop of styles) {\n        if (prop.startsWith('--')) {\n          ret[prop] = styles.getPropertyValue(prop);\n        }\n      }\n    }\n    return inline(ret);\n  }\n\n  function get_variable(element, name) {\n    return getComputedStyle(element).getPropertyValue(name)\n      .trim()\n      .replace(/^\\(|\\)$/g, '');\n\n  }\n\n  function inline(map) {\n    let result = [];\n    for (let prop in map) {\n      result.push(prop + ':' + map[prop]);\n    }\n    return result.join(';');\n  }\n\n  class Doodle extends HTMLElement {\n    constructor() {\n      super();\n      this.doodle = this.attachShadow({ mode: 'open' });\n      this.extra = {\n        get_variable: name => get_variable(this, name)\n      };\n    }\n\n    connectedCallback(again) {\n      if (/^(complete|interactive|loaded)$/.test(document.readyState)) {\n        this.load(again);\n      } else {\n        setTimeout(() => this.load(again));\n      }\n    }\n\n    update(styles) {\n      let use = this.get_use();\n      if (!styles) styles = this.innerHTML;\n      this.innerHTML = styles;\n\n      if (!this.grid_size) {\n        this.grid_size = this.get_grid();\n      }\n\n      let { x: gx, y: gy, z: gz } = this.grid_size;\n\n      const compiled = this.generate(\n        parse$1(use + styles, this.extra)\n      );\n\n      if (!this.shadowRoot.innerHTML) {\n        Object.assign(this.grid_size, compiled.grid);\n        return this.build_grid(compiled, compiled.grid);\n      }\n\n      if (compiled.grid) {\n        let { x, y, z } = compiled.grid;\n        if (gx !== x || gy !== y || gz !== z) {\n          Object.assign(this.grid_size, compiled.grid);\n          return this.build_grid(compiled, compiled.grid);\n        }\n        Object.assign(this.grid_size, compiled.grid);\n      }\n      else {\n        let grid = this.get_grid();\n        let { x, y, z } = grid;\n        if (gx !== x || gy !== y || gz !== z) {\n          Object.assign(this.grid_size, grid);\n          return this.build_grid(\n            this.generate(parse$1(use + styles, this.extra)),\n            grid\n          );\n        }\n      }\n\n      let svg_paths = this.build_svg_paths(compiled.paths);\n      if (svg_paths) {\n        let defs = this.shadowRoot.querySelector('.svg-defs');\n        if (defs) {\n          defs.innerHTML = svg_paths;\n        }\n      }\n\n      if (compiled.uniforms.time) {\n        this.register_uniform_time();\n      }\n\n      let replace = this.replace(compiled);\n\n      this.set_content('.style-keyframes', replace(compiled.styles.keyframes));\n\n      if (compiled.props.has_animation) {\n        this.set_content('.style-cells', '');\n        this.set_content('.style-container', '');\n      }\n\n      setTimeout(() => {\n        this.set_content('.style-container', replace(\n            get_grid_styles(this.grid_size)\n          + compiled.styles.host\n          + compiled.styles.container\n        ));\n        this.set_content('.style-cells', replace(compiled.styles.cells));\n      });\n    }\n\n    get grid() {\n      return Object.assign({}, this.grid_size);\n    }\n\n    set grid(grid) {\n      this.attr('grid', grid);\n      this.connectedCallback(true);\n    }\n\n    get seed() {\n      return this._seed_value;\n    }\n\n    set seed(seed) {\n      this.attr('seed', seed);\n      this.connectedCallback(true);\n    }\n\n    get use() {\n      return this.attr('use');\n    }\n\n    set use(use) {\n      this.attr('use', use);\n      this.connectedCallback(true);\n    }\n\n    static get observedAttributes() {\n      return ['grid', 'use', 'seed'];\n    }\n\n    attributeChangedCallback(name, old_val, new_val) {\n      if (old_val == new_val) {\n        return false;\n      }\n      let observed = ['grid', 'use', 'seed'].includes(name);\n      if (observed && !is_nil(old_val)) {\n        this[name] = new_val;\n      }\n    }\n\n    get_grid() {\n      return parse_grid(this.attr('grid'));\n    }\n\n    get_use() {\n      let use = this.attr('use') || '';\n      if (use) use = `@use:${ use };`;\n      return use;\n    }\n\n    attr(name, value) {\n      if (arguments.length === 1) {\n        return this.getAttribute(name);\n      }\n      if (arguments.length === 2) {\n        this.setAttribute(name, value);\n        return value;\n      }\n    }\n\n    generate(parsed) {\n      let grid = this.get_grid();\n      let seed = this.attr('seed') || this.attr('data-seed');\n\n      if (is_nil(seed)) {\n        seed = Date.now();\n      }\n\n      seed = String(seed);\n      this._seed_value = seed;\n\n      let random = this.random = seedrandom(seed);\n      let compiled = this.compiled = generator(parsed, grid, random);\n      return compiled;\n    }\n\n    doodle_to_image(code, options, fn) {\n      if (typeof options === 'function') {\n        fn = options;\n        options = null;\n      }\n      let parsed = parse$1(code, this.extra);\n      let _grid = parse_grid({});\n      let compiled = generator(parsed, _grid, this.random);\n      let grid = compiled.grid ? compiled.grid : _grid;\n      const { keyframes, host, container, cells } = compiled.styles;\n      let svg_defs = this.build_svg_paths(compiled.paths);\n\n      let replace = this.replace(compiled);\n      let grid_container = create_grid(grid);\n\n      let size = (options && options.width && options.height)\n        ? `width=\"${ options.width }\" height=\"${ options.height }\"`\n        : '';\n\n      replace(`\n      <svg ${ size } xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\">\n        <foreignObject width=\"100%\" height=\"100%\">\n          <div class=\"host\" xmlns=\"http://www.w3.org/1999/xhtml\">\n            <style>\n              ${ get_basic_styles() }\n              ${ get_grid_styles(grid) }\n              ${ host }\n              ${ container }\n              ${ cells }\n              ${ keyframes }\n            </style>\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0\" height=\"0\">\n              <defs class=\"svg-defs\">${ svg_defs }</defs>\n            </svg>\n            ${ grid_container }\n          </div>\n        </foreignObject>\n      </svg>\n    `).then(result => {\n        let source =`data:image/svg+xml;base64,${ window.btoa(unescape(encodeURIComponent(result))) }`;\n        if (is_safari()) {\n          cache_image(source);\n        }\n        fn(source);\n      });\n    }\n\n    shader_to_image({ shader, cell }, fn) {\n      let parsed = parse$2(shader);\n      let element = this.doodle.getElementById(cell);\n      let { width, height } = element.getBoundingClientRect();\n      let ratio = window.devicePixelRatio || 1;\n\n      if (!parsed.textures.length) {\n        draw_shader(parsed, width, height).then(fn);\n      }\n      // Need to bind textures first\n      else {\n        let transforms = parsed.textures.map(texture => {\n          return new Promise(resolve => {\n            this.doodle_to_image(texture.value, { width, height }, src => {\n              let img = new Image();\n              img.width = width * ratio;\n              img.height = height * ratio;\n              img.onload = () => resolve({ name: texture.name, value: img });\n              img.src = src;\n            });\n          });\n        });\n        Promise.all(transforms).then(textures => {\n          parsed.textures = textures;\n          draw_shader(parsed, width, height).then(fn);\n        });\n      }\n    }\n\n    load(again) {\n      if (!again) {\n        if (this.hasAttribute('click-to-update')) {\n          this.addEventListener('click', e => this.update());\n        }\n      }\n      let use = this.get_use();\n      if (!this.innerHTML.trim() && !use) {\n        return false;\n      }\n      let parsed = parse$1(use + un_entity(this.innerHTML), this.extra);\n      let compiled = this.generate(parsed);\n\n      this.grid_size = compiled.grid\n        ? compiled.grid\n        : this.get_grid();\n\n      this.build_grid(compiled, this.grid_size);\n    }\n\n    replace({ doodles, shaders, paths }) {\n      let doodle_ids = Object.keys(doodles);\n      let shader_ids = Object.keys(shaders);\n      let path_ids = Object.keys(paths);\n      return input => {\n        if (!doodle_ids.length && !shader_ids.length && !path_ids.length) {\n          return Promise.resolve(input);\n        }\n\n        let mappings = [].concat(\n          doodle_ids.map(id => {\n            if (input.includes(id)) {\n              return new Promise(resolve => {\n                this.doodle_to_image(doodles[id], value => resolve({ id, value }));\n              });\n            } else {\n              return Promise.resolve('');\n            }\n          }),\n          shader_ids.map(id => {\n            if (input.includes(id)) {\n              return new Promise(resolve => {\n                this.shader_to_image(shaders[id], value => resolve({ id, value }));\n              });\n            } else {\n              return Promise.resolve('');\n            }\n          }),\n          path_ids.map(id => {\n            if (input.includes(id)) {\n              return Promise.resolve({ id, value: '#' + id });\n            } else {\n              return Promise.resolve('');\n            }\n          })\n        );\n\n        return Promise.all(mappings).then(mapping => {\n          if (input.replaceAll) {\n            mapping.forEach(({ id, value }) => {\n              input = input.replaceAll('${' + id + '}', `url(${value})`);\n            });\n          } else {\n            mapping.forEach(({ id, value }) => {\n              input = input.replace('${' + id + '}', `url(${value})`);\n            });\n          }\n          return input;\n        });\n      }\n    }\n\n    build_grid(compiled, grid) {\n      const { has_transition, has_animation } = compiled.props;\n      let has_delay = (has_transition || has_animation);\n\n      const { keyframes, host, container, cells } = compiled.styles;\n      let style_container = get_grid_styles(grid) + host + container;\n      let style_cells = has_delay ? '' : cells;\n      let svg_defs = this.build_svg_paths(compiled.paths);\n\n      const { uniforms } = compiled;\n\n      let replace = this.replace(compiled);\n\n      this.doodle.innerHTML = `\n      <style>${ get_basic_styles(uniforms) }</style>\n      <style class=\"style-keyframes\">${ keyframes }</style>\n      <style class=\"style-container\">${ style_container }</style>\n      <style class=\"style-cells\">${ style_cells }</style>\n      <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0\" height=\"0\">\n        <defs class=\"svg-defs\">${ svg_defs }</defs>\n      </svg>\n      ${ create_grid(grid) }\n    `;\n\n      this.set_content('.style-container', replace(style_container));\n\n      if (has_delay) {\n        setTimeout(() => {\n          this.set_content('.style-cells', replace(cells));\n        }, 50);\n      } else {\n        this.set_content('.style-cells', replace(cells));\n      }\n\n      // might be removed in the future\n      const definitions = compiled.definitions;\n      if (window.CSS && window.CSS.registerProperty) {\n        try {\n          if (uniforms.time) {\n            this.register_uniform_time();\n          }\n          definitions.forEach(CSS.registerProperty);\n        } catch (e) { }\n      }\n    }\n\n    build_svg_paths(paths) {\n      let names = Object.keys(paths || {});\n      return names.map(name => `\n      <clipPath id=\"${ paths[name].id }\" clipPathUnits=\"objectBoundingBox\">\n        <path d=\"${ paths[name].commands }\" />\n      </clipPath>\n    `).join('');\n    }\n\n    register_uniform_time() {\n      if (!this.is_uniform_time_registered) {\n        try {\n          CSS.registerProperty({\n            name: '--' + uniform_time.name,\n            syntax: '<number>',\n            initialValue: 0,\n            inherits: true\n          });\n        } catch (e) {}\n        this.is_uniform_time_registered = true;\n      }\n    }\n\n    export({ scale, name, download, detail } = {}) {\n      return new Promise((resolve, reject) => {\n        let variables = get_all_variables(this);\n        let html = this.doodle.innerHTML;\n\n        let { width, height } = this.getBoundingClientRect();\n        scale = parseInt(scale) || 1;\n\n        let w = width * scale;\n        let h = height * scale;\n\n        let svg = minify(`\n        <svg xmlns=\"http://www.w3.org/2000/svg\"\n          preserveAspectRatio=\"none\"\n          viewBox=\"0 0 ${ width } ${ height }\"\n          ${ is_safari() ? '' : `width=\"${ w }px\" height=\"${ h }px\"` }\n        >\n          <foreignObject width=\"100%\" height=\"100%\">\n            <div\n              class=\"host\"\n              xmlns=\"http://www.w3.org/1999/xhtml\"\n              style=\"width: ${ width }px; height: ${ height }px; \"\n            >\n              <style>.host { ${variables} }</style>\n              ${ html }\n            </div>\n          </foreignObject>\n        </svg>\n      `);\n\n        if (download || detail) {\n          svg_to_png(svg, w, h, scale)\n            .then(({ source, url, blob }) => {\n              resolve({\n                width: w, height: h, svg, blob, source\n              });\n              if (download) {\n                let a = document.createElement('a');\n                a.download = normalize_png_name(name);\n                a.href = url;\n                a.click();\n              }\n            })\n            .catch(error => {\n              reject(error);\n            });\n        } else {\n          resolve({\n            width: w, height: h, svg: svg\n          });\n        }\n      });\n    }\n\n    set_content(selector, styles) {\n      if (styles instanceof Promise) {\n        styles.then(value => {\n          this.set_content(selector, value);\n        });\n      } else {\n        const el = this.shadowRoot.querySelector(selector);\n        el && (el.styleSheet\n          ? (el.styleSheet.cssText = styles )\n          : (el.innerHTML = styles));\n      }\n    }\n  }\n\n  if (!customElements.get('css-doodle')) {\n    customElements.define('css-doodle', Doodle);\n  }\n\n  function get_basic_styles(uniforms = {}) {\n    const inherited_grid_props = get_props(/grid/)\n      .map(n => `${ n }: inherit;`)\n      .join('');\n    return `\n    * {\n      box-sizing: border-box\n    }\n    *::after, *::before {\n      box-sizing: inherit\n    }\n    :host, .host {\n      display: block;\n      visibility: visible;\n      width: auto;\n      height: auto;\n      --${ uniform_time.name }: 0\n    }\n    :host([hidden]), .host[hidden] {\n      display: none\n    }\n    .container {\n      position: relative;\n      width: 100%;\n      height: 100%;\n      display: grid;\n      ${ inherited_grid_props }\n    }\n    cell:empty {\n      position: relative;\n      line-height: 1;\n      display: grid;\n      place-items: center\n    }\n    svg {\n      position: absolute;\n    }\n  `;\n  }\n\n  function get_grid_styles({x, y}) {\n    return `\n    :host, .host {\n      grid-template-rows: repeat(${ y }, 1fr);\n      grid-template-columns: repeat(${ x }, 1fr);\n    }\n  `;\n  }\n\n  function minify(input) {\n    return input\n      .replace(/\\n\\s+|^\\s+|\\n+/g, ' ')\n      .trim();\n  }\n\n  function create_cell(x, y, z) {\n    let cell = document.createElement('cell');\n    cell.id = cell_id(x, y, z);\n    return cell;\n  }\n\n  function create_grid({ x, y, z }) {\n    let grid = document.createElement('grid');\n    let root = document.createDocumentFragment();\n    if (z == 1) {\n      for (let j = 1; j <= y; ++j) {\n        for (let i = 1; i <= x; ++i) {\n          root.appendChild(create_cell(i, j, 1));\n        }\n      }\n    }\n    else {\n      let temp = null;\n      for (let i = 1; i <= z; ++i) {\n        let cell = create_cell(1, 1, i);\n        (temp || root).appendChild(cell);\n        temp = cell;\n      }\n      temp = null;\n    }\n    grid.className = 'container';\n    grid.appendChild(root);\n    return grid.outerHTML;\n  }\n\n  function CSSDoodle(input, ...vars) {\n    let get_value = v => is_nil(v) ? '' : v;\n    let rules = input.reduce((s, c, i) => s + c + get_value(vars[i]), '');\n    let doodle = document.createElement('css-doodle');\n    if (doodle.update) {\n      doodle.update(rules);\n    }\n    return doodle;\n  }\n\n  return CSSDoodle;\n\n})));\n"]},"metadata":{},"sourceType":"script"}